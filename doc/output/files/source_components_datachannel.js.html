<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Temasys Web SDK Documentation (0.6.19)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="name" content="skylinkjs">
  <meta name="version" content="0.6.19">
  <!-- Favicon -->
  <link href="../assets/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
  <link href="../assets/vendor/font-awesome.min.css" rel="stylesheet" type="text/css">
  <!-- Styles -->
  <link href="../assets/vendor/prettify.min.css" rel="stylesheet" type="text/css">
  <link href="../assets/css/main.css" rel="stylesheet" type="text/css">
  <script src="../assets/vendor/jquery.min.js" type="text/javascript"></script>
  <script src="../assets/vendor/prettify.min.js" type="text/javascript"></script>
  <script src="../assets/js/main.js" type="text/javascript"></script>
</head>
<body>
  <!-- Navigation Header -->
  <navbar class="top">
    <a class="main" href="/">
      <img src="../assets/img/favicon.ico">
      <strong>Temasys</strong> Web SDK
    </a>
    <ul class="menu">
      <li><a href="https://github.com/Temasys/SkylinkJS" target="_blank">SkylinkJS Github</a></li>
      <li><a href="https://console.temasys.io/" target="_blank">Developer Console</a></li>
    </ul>
  </navbar>

  <!-- Body -->
  <section class="container">
    <div class="container-wrapper">
      <!-- Side Navigation -->
      <navbar class="side">
        <div id="side-menu" class="navbar-wrapper">
          <ul class="menu">
            <div class="section">
              <span class="header">Getting Started</span>    
              <li>
              <a href="#">1. Overview <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Architecture</a></li>
                  <li><a href="#">b. Authentication Methods</a></li>
                  <li><a href="#">c. Persistent Rooms</a></li>
                  <li><a href="#">d. Auto-Introduce & Privileged</a></li>
              </ul>
              </li>
              <li>
              <a href="#">2. Integrating to Your Site <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Referencing the SDK</a></li>
                  <li><a href="#">b. Code Samples</a></li>
                  <li><a href="#">c. Integrating your extensions & WebRTC plugin</a></li>
              </ul>
              </li>
              <li><a href="#" class="nodropdown">3. Demos</a></li>
            </div>
            <div class="section">
              <span class="header">API Documentation</span>
              <li>
                <a href="#">Temasys <small>module</small><i class="fa fa-caret-down"></i></a>
                <ul>
                </ul>
              </li>
                  ([&quot;Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Room.html" class="nodropdown">
                      Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Skylink&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Skylink.html" class="nodropdown">
                      Skylink <small>class</small>
                    </a>
                  </li>
                  ([&quot;Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Socket.html" class="nodropdown">
                      Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.html" class="nodropdown">
                      Temasys <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Datachannel&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Datachannel.html" class="nodropdown">
                      Temasys.Datachannel <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Peer&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Peer.html" class="nodropdown">
                      Temasys.Peer <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Room.html" class="nodropdown">
                      Temasys.Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Socket.html" class="nodropdown">
                      Temasys.Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Stream&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Stream.html" class="nodropdown">
                      Temasys.Stream <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Utils.html" class="nodropdown">
                      Temasys.Utils <small>class</small>
                    </a>
                  </li>
            </div>
          </ul>
        </div>
      </navbar>      <!-- Content -->
      <h1 class="file-heading">File: source/components/datachannel.js</h1>
      
      <div class="file">
          <pre class="code prettyprint linenums">
      /**
       * Handles the native &#x60;RTCDataChannel&#x60; object connection.
       * @class Temasys.Datachannel
       * @constructor
       * @private
       * @for Temasys
       * @since 0.7.0
       */
      function Datachannel (channel, peerId, propertyId) {
        
        /**
         * The Datachannel ID.
         * @attribute id
         * @type String
         * @readOnly
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        this.id = channel.label;
      
        /**
         * The Datachannel type.
         * - See {{#crossLink &quot;Temasys.Datachannel/TYPE_ENUM:attribute&quot;}}{{/crossLink}} for reference.
         * @attribute type
         * @type String
         * @readOnly
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        this.type = propertyId === &#x27;main&#x27; ? this.TYPE_ENUM.MESSAGING : this.TYPE_ENUM.DATA;
      
        /**
         * The Datachannel current states.
         * @attribute $current
         * @param {String} state The current Datachannel connection state.
         * @param {Boolean} connected The flag if Datachannel is connected.
         * @param {String} streamId The current Datatransfer streaming session ID.
         * @param {String} transferId The current Datatransfer transfer session ID.
         * @type JSON
         * @readOnly
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        this.$current = {
          state: null,
          connected: false,
          streamId: null,
          transferId: null
        };
        
        // Public properties
        this.name = channel.label;
        this.peerId = peerId;
        this.propertyId = propertyId;
        // Private properties
        this._connection = channel;
        this._bufferControl = {
          usePolling: typeof this._connection.bufferedAmountLowThreshold !== &#x27;number&#x27;,
          bufferEvent: { block: 0.5 },
          polling: { blocks: 8, interval: 250 },
          messages: { timestamp: 0, flushTimeout: 100, finalFlushTimeout: 2000 }
        };
        this._stats = {
          messages: { sent: 0, recv: 0 },
          bytes: { sent: 0, recv: 0 }
        };
      
        /**
         * Event triggered when Datachannel connection state has been changed.
         * @event stateChange
         * @param {String} state The current Datachannel connection state.
         * - See {{#crossLink &quot;Temasys.Datachannel/STATE_ENUM:attribute&quot;}}{{/crossLink}} for reference.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        /**
         * Event triggered when Datachannel connection has encountered errors.
         * @event error
         * @param {Error} error The error object.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        /**
         * Event triggered when Datachannel connection buffered amount threshold is low.
         * @event bufferedAmountLow
         * @param {Number} bufferedAmount The current buffered amount in bytes.
         * @param {Number} bufferedAmountLowThreshold The current buffered amount threshold set in bytes.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        /**
         * Event triggered when Datachannel connection sends or receives data.
         * @event data
         * @param {JSON|Blob} data The data.
         * @param {Boolean} isSelf The flag if data is sent from self.
         * @param {Error} [error] The error object.
         * - This is defined when data failed to send or parse received data.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        /**
         * Event triggered when there are exceptions thrown in this event handlers.
         * @event domError
         * @param {Error} error The error object.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        /**
         * Event triggered when stats retrieval state has changed.
         * @event getStatsStateChange
         * @param {String} state The current stats retrieval state.
         * - See {{#crossLink &quot;Temasys.Datachannel/GET_STATS_STATE_ENUM:attribute&quot;}}{{/crossLink}} for reference.
         * @param {JSON} [stats] The stats.
         * - This is defined when &#x60;state&#x60; is &#x60;SUCCESS&#x60;.
         * @param {String} stats.id The native &#x60;RTCDataChannel&#x60; object &#x60;.id&#x60; property.
         * @param {String} stats.label The native &#x60;RTCDataChannel&#x60; object &#x60;.label&#x60; property.
         * @param {String} stats.binaryType The native &#x60;RTCDataChannel&#x60; object &#x60;.binaryType&#x60; property.
         * - This indicates the type of native object type it uses to send and pack received binary data.
         * @param {Number} stats.bufferedAmount The current Datachannel connection buffered amount in bytes.
         * @param {Number} stats.bufferedAmountLowThreshold The current Datachannel connection
         *   buffered amount low threshold in bytes.
         * @param {JSON} stats.messages The messages stats.
         * @param {Number} stats.messages.sent The number of messages sent from this Datachannel connection.
         * @param {Number} stats.messages.received The number of messages received from this Datachannel connection.
         * @param {JSON} stats.bytes The bytes stats.
         * @param {Number} stats.bytes.sent The number of bytes sent from this Datachannel connection.
         * @param {Number} stats.bytes.received The number of bytes received from this Datachannel connection.
         * @param {JSON} stats.bufferControlOptions The current Datachannel connection buffer control settings.
         * @param {String} stats.bufferControlOptions.method The current Datachannel connection buffer control method.
         * - Available methods are: &#x60;&quot;polling&quot;&#x60; (Polling) and &#x60;&quot;bufferedAmount&quot;&#x60; (Buffer amount threshold).
         * @param {Number} stats.bufferControlOptions.block The current Datachannel connection buffer control full threshold block.
         * @param {Number} [stats.bufferControlOptions.interval] The current Datachannel connection buffer control polling interval.
         * - This is defined only for Polling method.
         * @param {Number} stats.bufferControlOptions.flushTimeout The current Datachannel connection timeout to consider that
         *   the packet has been sent.
         * @param {Number} stats.bufferControlOptions.finalFlushTimeout The current Datachannel connection timeout
         *   to consider that all the packets has been sent before the Datachannel connection closes explicitly.
         * @param {Error} [error] The error object.
         * - This is defined when &#x60;state&#x60; is &#x60;FAILED&#x60;.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
        /**
         * Event triggered when there are exceptions thrown in this event handlers.
         * @event domError
         * @param {Error} error The error object.
         * @for Temasys.Datachannel
         * @since 0.7.0
         */
      }
      
      /**
       * The enum of Datachannel connection states.
       * @attribute STATE_ENUM
       * @param {String} CONNECTING The state when Datachannel connection is connecting.
       * @param {String} OPEN The state when Datachannel connection has opened.
       * @param {String} CLOSING The state when Datachannel connection is closing.
       * @param {String} CLOSED The state when Datachannel connection has closed.
       * @readOnly
       * @final
       * @for Temasys.Datachannel
       * @since 0.7.0
       */
      Datachannel.prototype.STATE_ENUM = {
      	CONNECTING: &#x27;connecting&#x27;,
        OPEN: &#x27;open&#x27;,
        CLOSING: &#x27;closing&#x27;,
        CLOSED: &#x27;closed&#x27;
      };
      
      /**
       * The enum of {{#crossLink &quot;Temasys.Datachannel/getStats:method&quot;}}{{/crossLink}} states.
       * @attribute GET_STATS_STATE_ENUM
       * @param {String} LOADING The state when &#x60;getStats()&#x60; is retrieving stats.
       * @param {String} SUCCESS The state when &#x60;getStats()&#x60; has retrieved stats successfully.
       * @param {String} FAILED The state when &#x60;getStats()&#x60; has failed to retrieve stats.
       * @readOnly
       * @final
       * @for Temasys.Datachannel
       * @since 0.7.0
       */
      Datachannel.prototype.GET_STATS_STATE_ENUM = {
      	LOADING: &#x27;loading&#x27;,
        SUCCESS: &#x27;success&#x27;,
        FAILED: &#x27;failed&#x27;
      };
      
      /**
       * Function to retrieve Datachannel connection stats.
       * @method getStats
       * @return {Promise} The Promise for function request completion.
       * @example
       *   channel.getStats().then(function (stats) {
       *     console.log(&quot;Received stats -&gt;&quot;, stats);
       *   }).catch(function (error) {
       *     console.error(&quot;Received error -&gt;&quot;, error);
       *   });
       * @for Temasys.Datachannel
       * @since 0.7.0
       */
      Datachannel.prototype.getStats = function () {
        var self = this;
      
        return {
          readyState: self._connection.readyState,
          id: self._connection.id,
          label: self._connection.label,
          binaryType: self._connection.binaryType,
          bufferedAmount: parseInt(self._connection.bufferedAmount, 10) || 0,
          bufferedAmountLowThreshold: self._connection.bufferedAmountLowThreshold || 0,
          messagesSent: self._stats.messages.sent,
          messagesReceived: self._stats.messages.recv,
          bytesSent: self._stats.bytes.sent,
          bytesReceived: self._stats.bytes.recv
        };
      };
      
      /**
       * Function to start initializing events.
       */
      Datachannel.prototype.init = function () {
        var self = this;
      
        // Handle RTCDataChannel.onopen event
        var onOpenFn = function () {
          self._emit(&#x27;state&#x27;, &#x27;open&#x27;);
        };
      
        if (self._connection.readyState === &#x27;open&#x27;) {
          // Set some time to append data before starting transfers
          setTimeout(onOpenFn, 1);
        } else {
          self._connection.onopen = onOpenFn;
          self._emit(&#x27;state&#x27;, self._connection.readyState);
        }
      
        // Handle RTCDataChannel.onclose event
        var onCloseFn = function () {
          self._emit(&#x27;state&#x27;, &#x27;closed&#x27;);
        };
      
        // Fixes for Firefox bug (49 is working) -&gt; https://bugzilla.mozilla.org/show_bug.cgi?id=1118398
        if (window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
          var closed = false;
          var block = 0;
      
          self._connection.onclose = function () {
            if (!closed) {
              closed = true;
              onCloseFn();
            }
          };
      
          var closedChecker = setInterval(function () {
            if (self._connection.readyState === &#x27;closed&#x27; || closed || block === 5) {
              clearInterval(closedChecker);
              if (!closed) {
                closed = true;
                onCloseFn();
              }
            // After 5 seconds when state is &quot;closed&quot;, it&#x27;s actually closed on Firefox&#x27;s end.
            } else if (self._connection.readyState === &#x27;closing&#x27;) {
              block++;
            }
          }, 1000);
        } else {
          self._connection.onclose = onCloseFn;
        }
      
        // Handle RTCDataChannel.onmessage event
        self._connection.onmessage = function (evt) {
          self._stats.messages.recv++;
          self._stats.bytes.recv += typeof evt.data === &#x27;string&#x27; ? Utils.getStringByteLength(evt.data) :
            (evt.data.byteLength || evt.data.size || 0);
          self._emit(&#x27;data&#x27;, evt.data);
        };
      
        // Handle RTCDataChannel.onbufferedamountlow event
        self._connection.onbufferedamountlow = function () {
          self._emit(&#x27;bufferedamountlow&#x27;);
        };
      
        // Handle RTCDataChannel.onerror event
        self._connection.onerror = function (evt) {
          self._emit(&#x27;error&#x27;, evt.error || new Error(&#x27;Datachannel error occurred.&#x27;));
        };
      };
      
      /**
       * Function to send data.
       */
      Datachannel.prototype.send = function (data, useBufferControl) {
        var self = this;
        var dataSize = data.byteLength || data.length || data.size || 0;
      
        if (dataSize === 0) {
          self._emit(&#x27;senderror&#x27;, data, new Error(&#x27;Data size is 0.&#x27;));
          return;
        }
      
        try {
          // For implementing reliable mode where direct data packets are sent without congestion control or ACKs control
          // For some reasons, RTCDataChannel.bufferedAmount returns 0 always in IE/Safari/Firefox.
          // See: https://jira.temasys.com.sg/browse/TWP-670
          if (useBufferControl) {
            var fullBufferThreshold = dataSize * (self._bufferControl.usePolling ?
              self._bufferControl.polling.blocks : self._bufferControl.bufferEvent.blocks);
      
            self._connection.bufferedAmountLowThreshold = fullBufferThreshold;
      
            // Fixes: https://jira.temasys.com.sg/browse/TWP-569
            if (parseInt(self._connection.bufferedAmount, 10) &gt;= fullBufferThreshold) {
              // Wait for the next 250ms to check again
              if (self._bufferControl.usePolling) {
                setTimeout(function () {
                  self.send(data, true);
                }, self._bufferControl.polling.interval);
              // Wait for RTCDataChannel.onbufferedamountlow event to triggered
              } else {
                self.once(&#x27;bufferedamountlow&#x27;, function () {
                  self.send(data, true);
                });
              }
              return;
            }
          }
      
          self._connection.send(data);
          self._stats.messages.sent++;
          self._stats.bytes.recv += typeof data === &#x27;string&#x27; ? Utils.getStringByteLength(data) :
            (data.byteLength || data.size || 0);
      
          if (useBufferControl) {
            self._bufferControl.messages.timestamp = Date.now();
            setTimeout(function () {
              self._emit(&#x27;send&#x27;, data);
            }, self._bufferControl.messages.flushTimeout);
            return;
          }
      
          self._emit(&#x27;send&#x27;, data);
      
        } catch (error) {
          self._emit(&#x27;senderror&#x27;, data, error);
        }
      };
      
      /**
       * Function to close connection.
       */
      Datachannel.prototype.close = function () {
        var self = this;
      
        if ([&#x27;closed&#x27;, &#x27;closing&#x27;].indexOf(self._connection.readyState) === -1) {
          var now = Date.now();
          // Prevent the Datachannel from closing if there is an ongoing buffer sent
          // Use the polling interval here because the bufferedamountlow event is just an indication of
          // &quot;ready&quot; to send next packet because threshold is lower now
          // See Firefox case where it has to be really fast enough: https://bugzilla.mozilla.org/show_bug.cgi?id=933297
          // Fixes: https://jira.temasys.com.sg/browse/TWP-569
          if (parseInt(self._connection.bufferedAmount, 10) &gt; 0) {
            setTimeout(function () {
              self.close();
            }, self._bufferControl.polling.interval);
            return;
          }
      
          // Prevent closing too fast if the packet has been sent within last than expected time interval
          if ((now - self._bufferControl.messages.timestamp) &gt;= self._bufferControl.messages.finalFlushTimeout) {
            setTimeout(function () {
              self.close();
            }, (now - self._bufferControl.messages.timestamp) - self._bufferControl.messages.finalFlushTimeout);
            return;
          }
      
          self._emit(&#x27;state&#x27;, &#x27;closing&#x27;);
          self._connection.close();
        }
      };
          </pre>
      </div>
    </div>
   </section>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Temasys Web SDK Documentation (0.6.19)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="name" content="skylinkjs">
  <meta name="version" content="0.6.19">
  <!-- Favicon -->
  <link href="../assets/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
  <link href="../assets/vendor/font-awesome.min.css" rel="stylesheet" type="text/css">
  <!-- Styles -->
  <link href="../assets/vendor/prettify.min.css" rel="stylesheet" type="text/css">
  <link href="../assets/css/main.css" rel="stylesheet" type="text/css">
  <script src="../assets/vendor/jquery.min.js" type="text/javascript"></script>
  <script src="../assets/vendor/prettify.min.js" type="text/javascript"></script>
  <script src="../assets/js/main.js" type="text/javascript"></script>
</head>
<body>
  <!-- Navigation Header -->
  <navbar class="top">
    <a class="main" href="/">
      <img src="../assets/img/favicon.ico">
      <strong>Temasys</strong> Web SDK
    </a>
    <ul class="menu">
      <li><a href="https://github.com/Temasys/SkylinkJS" target="_blank">SkylinkJS Github</a></li>
      <li><a href="https://console.temasys.io/" target="_blank">Developer Console</a></li>
    </ul>
  </navbar>

  <!-- Body -->
  <section class="container">
    <div class="container-wrapper">
      <!-- Side Navigation -->
      <navbar class="side">
        <div id="side-menu" class="navbar-wrapper">
          <ul class="menu">
            <div class="section">
              <span class="header">Getting Started</span>    
              <li>
              <a href="#">1. Overview <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Architecture</a></li>
                  <li><a href="#">b. Authentication Methods</a></li>
                  <li><a href="#">c. Persistent Rooms</a></li>
                  <li><a href="#">d. Auto-Introduce & Privileged</a></li>
              </ul>
              </li>
              <li>
              <a href="#">2. Integrating to Your Site <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Referencing the SDK</a></li>
                  <li><a href="#">b. Code Samples</a></li>
                  <li><a href="#">c. Integrating your extensions & WebRTC plugin</a></li>
              </ul>
              </li>
              <li><a href="#" class="nodropdown">3. Demos</a></li>
            </div>
            <div class="section">
              <span class="header">API Documentation</span>
              <li>
                <a href="#">Temasys <small>module</small><i class="fa fa-caret-down"></i></a>
                <ul>
                </ul>
              </li>
                  ([&quot;Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Room.html" class="nodropdown">
                      Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Skylink&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Skylink.html" class="nodropdown">
                      Skylink <small>class</small>
                    </a>
                  </li>
                  ([&quot;Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Socket.html" class="nodropdown">
                      Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Peer&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Peer.html" class="nodropdown">
                      Temasys.Peer <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Room.html" class="nodropdown">
                      Temasys.Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Socket.html" class="nodropdown">
                      Temasys.Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Utils.html" class="nodropdown">
                      Temasys.Utils <small>class</small>
                    </a>
                  </li>
                  ([&quot;Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Utils.html" class="nodropdown">
                      Utils <small>class</small>
                    </a>
                  </li>
            </div>
          </ul>
        </div>
      </navbar>      <!-- Content -->
      <h1 class="file-heading">File: source/components/room.js</h1>
      
      <div class="file">
          <pre class="code prettyprint linenums">
      /**
       * Handles the Room connection session.
       * @class Temasys.Room
       * @param {JSON} options The options.
       * @param {String} options.appKey The App Key ID to connect to the App space to.
       * @param {String} [options.name] The Room name to connect to.
       *   The default is the App Key ID value.
       * @param {Boolean} [options.autoInit=true] The flag if {{#crossLink &quot;Room/init:method&quot;}}{{/crossLink}}
       *   should be automatically called the moment the Room class object is constructed.
       * @param {Boolean} [options.requireWebRTC=true] The flag if WebRTC functionalities are required mandatorily.
       *   If the browser or device does not support WebRTC functionalities, a normal Signaling server connection commences.
       * @constructor
       * @since 0.7.0
       */
      function Room (options) {
        options = options &amp;&amp; typeof options === &#x27;object&#x27; ? options : {};
      
        /**
         * The Auth (API) server domain.
         * @attribute server
         * @type String
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.server = &#x27;api.temasys.io&#x27;;
      
        /**
         * The Auth (API) server protocol.
         * @attribute protocol
         * @type String
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.protocol = null;
      
        /**
         * The Auth (API) server domain.
         * @attribute server
         * @type String
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.appKey = options.appKey &amp;&amp; typeof options.appKey === &#x27;string&#x27; ? options.appKey : null;
      
        /**
         * The Room name.
         * @attribute name
         * @type String
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.name = options.name &amp;&amp; typeof options.name === &#x27;string&#x27; ? options.name : this.appKey;
      
        /**
         * The Room ID.
         * @attribute id
         * @type String
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.id = null;
      
        /**
         * The Room session start timestamp in ISO-8601 format.
         * @attribute start
         * @type String
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.start = null;
      
        /**
         * The Room session duration in hours.
         * @attribute duration
         * @type Number
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.duration = null;
      
        /**
         * The Room session hash used only for hash based authentication.
         * @attribute hash
         * @type String
         * @readOnly
         * @optional
         * @for Room
         * @since 0.7.0
         */
        this.hash = null;
      
        /**
         * The flag if Room session has auto-introduce enabled.
         * @attribute autoIntroduce
         * @type Boolean
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.autoIntroduce = true;
      
        /**
         * The Room session self Peer information.
         * @attribute peer
         * @param {String} id The session Peer ID.
         * @param {String} parentId The session parent Peer ID its linked to.
         * @param {Any} data The session custom data.
         * @param {Number} priorityWeight The session Peer priority weight.
         * @param {Boolean} isPrivileged The flag if session Peer has privileged access.
         * @param {JSON} agent The session Peer agent information.
         * @param {String} agent.name The session Peer agent name.
         * @param {String} agent.version The session Peer agent version.
         * @param {String} agent.os The session Peer agent platform.
         * @param {String} [agent.pluginVersion] The session Peer agent Temasys WebRTC version.
         * @param
         * @type JSON
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.peer = {
          id: null,
          peerId: null,
          data: null,
          priorityWeight: null,
          isPrivileged: false,
          agent: {
            name: window.webrtcDetectedBrowser,
            version: (window.webrtcDetectedVersion || 0).toString(),
            os: window.navigator.platform,
            pluginVersion: globals.AdapterJS &amp;&amp; globals.AdapterJS.WebRTCPlugin &amp;&amp;
              globals.AdapterJS.WebRTCPlugin.plugin &amp;&amp; globals.AdapterJS.WebRTCPlugin.plugin.VERSION
          }
        };
      
        /**
         * The WebRTC supports of the browser or device.
         * @attribute webrtcSupports
         * @param {Boolean} enabled The flag if WebRTC is enabled for this browser or device.
         * @param {JSON} audioCodecs The list of supported audio codecs.
         * @param {Array} audioCodecs.#codec The list of the sampling rate and its channels the audio codec supports.
         * @param {String} audioCodecs.#codec.#index The audio codec supported sampling rate and its channel item.
         *   Format is &#x60;samplingRate/channels&#x60;.
         * @param {JSON} videoCodecs The list of supported video codecs.
         * @param {Array} videoCodecs.#codec The list of the sampling rate the video codec supports.
         * @param {String} videoCodecs.#codec.#index The video codec supported sampling rate and its channel item.
         *   Format is &#x60;samplingRate&#x60;.
         * @param {Boolean} dataChannel The flag if Datachannel connections is supported for this browser or device.
         * @param {String} [dataChannelBinaryType] The Datachannel binary type interface it supports.
         * @type JSON
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.webrtcSupports = {
          enabled: false,
          audioCodecs: {},
          videoCodecs: {},
          dataChannel: false,
          dataChannelBinaryType: null,
          iceRestart: !(window.webrtcDetectedBrowser === &#x27;firefox&#x27; &amp;&amp; window.webrtcDetectedVersion &lt; 48)
        };
      
        /**
         * The current Room session connection status.
         * @attribute current
         * @param {String} peerId The User Peer session ID.
         * @param {String} authState The Room authentication state.
         * @param {Boolean} connected The flag if User is connected to the Room.
         * @param {Boolean} locked The flag if Room is locked.
         * @param {Boolean} isMCUEnabled The flag if Room has MCU enabled for Peer connections.
         * @type JSON
         * @readOnly
         * @for Room
         * @since 0.7.0
         */
        this.current = {
          initState: null,
          authState: null,
          sessionState: null,
          connected: false,
          locked: false,
          isMCUEnabled: false
        };
      
        // Private variables
        this._session = null;
        this._peers = {};
        this._socket = null;
        this._defaultStream = null;
        this._config = {
          iceServers: [],
          requireWebRTC: options.requireWebRTC !== false,
          autoInit: options.autoInit !== false,
          priorityWeightScheme: null,
          defaultSettings: {
            enableIceTrickle: true,
            enableDataChannel: true,
            connection: {
      
            }
          }
        };
      
      
        // Events
        /**
         * Event triggered when Room authentication state has changed.
         * @event authState
         * @param {String} state The current authentication state.
         *   References the {{#crossLink &quot;Socket/AUTH_STATE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @param {JSON} error The error.
         *   This is defined when &#x60;state&#x60; value is &#x60;STATE_ENUM.ERROR&#x60;.
         * @param {Error} error.error The error object.
         * @param {Number} error.code The error code.
         *   References the {{#crossLink &quot;Socket/AUTH_ERROR_CODE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @param {Number} error.httpStatus The returned HTTP status.
         * @for Room
         * @since 0.7.0
         */
        /**
         * Event triggered when Room init state has changed.
         * @event initState
         * @param {String} state The current init state.
         *   References the {{#crossLink &quot;Socket/INIT_STATE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @param {JSON} error The error.
         * @param {Error} error.error The error object.
         * @param {Number} error.code The error code.
         *   References the {{#crossLink &quot;Socket/INIT_ERROR_CODE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @for Room
         * @since 0.7.0
         */
        /**
         * Event triggered when Room session state has changed.
         * @event sessionState
         * @param {String} state The current init state.
         *   References the {{#crossLink &quot;Socket/INIT_STATE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @param {JSON} error The error.
         * @param {Error} error.error The error object.
         * @param {Number} error.code The error code.
         *   References the {{#crossLink &quot;Socket/INIT_ERROR_CODE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @for Room
         * @since 0.7.0
         */
        /**
         * Event triggered when there are exceptions thrown in this event handlers.
         * @event domError
         * @param {Error} error The error object.
         * @for Socket
         * @since 0.7.0
         */
        (function (ref) {
          /**
           * Function to subscribe to an event.
           * @method on
           * @param {String} event The event to subscribe to once.
           * @param {Function} callback The callback listener function.
           * @for Room
           * @since 0.7.0
           */
          ref.on = ref._event.on;
      
          /**
           * Function to subscribe to an event once.
           * @method once
           * @param {String} event The event to subscribe to once.
           * @param {Function} callback The callback listener function.
           * @param {Function} [condition] The condition function that is called when
           *   event is triggered. If condition is met (when function returns &#x60;true&#x60;), the
           *   callback listener function is triggered.
           *   The default is &#x60;function () { return true; }&#x60;.
           * @param {Boolean} [fireAlways] The flag if callback listener function should always
           *   be triggered regardless as long as condition function is met.
           *   The default is &#x60;false&#x60;.
           * @for Room
           * @since 0.7.0
           */
          ref.once = ref._event.once;
      
          /**
           * Function to unsubscribe to events.
           * @method off
           * @param {String} [event] The specified event to unsubscribe.
           *   When not provided, it will unsubscribe all event callback listener functions.
           * @param {Function} [callback] The specified callback listener function based on
           *   the provided event to unsubscribe only.
           *   When not provided, it will unsubscribe all callback listener functions subscribed to the event.
           * @for Room
           * @since 0.7.0
           */
          ref.off = ref._event.off;
      
          // Catch errors to prevent issues for Room connection
          ref._event.catch(function (error) {
            ref._event.emit(&#x27;domError&#x27;, error);
          });
      
          if (ref._config.autoInit) {
            setTimeout(function () {
              ref.init();
            }, 1);
          }
        })(this);
      }
      
      /**
       * The Room SM protocol version supports.
       * @attribute SM_PROTOCOL_VERSION
       * @type String
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.SM_PROTOCOL_VERSION = &#x27;0.1.2.3&#x27;;
      
      /**
       * The Room DT protocol version supports.
       * @attribute DT_PROTOCOL_VERSION
       * @type String
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.DT_PROTOCOL_VERSION = &#x27;0.1.3&#x27;;
      
      /**
       * The enum of Room dependency initialising states.
       * @attribute INIT_STATE_ENUM
       * @param {Number} LOADING The state when Room is initialising.
       * @param {Number} COMPLETED The state when Room has initialised.
       * @param {Number} ERROR The state when Room failed to initialise.
       * @type JSON
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.INIT_STATE_ENUM = {
        LOADING: 0,
        COMPLETED: 1,
        ERROR: -1
      };
      
      /**
       * The enum of Room dependency initialising error codes.
       * @attribute INIT_ERROR_CODE_ENUM
       * @param {Number} NO_SOCKET_IO The error code when the required socket.io-client dependency is not loaded.
       * @param {Number} ADAPTER_NO_LOADED The error code when the required AdapterJS dependency is not loaded.
       * @param {Number} NO_XMLHTTPREQUEST_SUPPORT The error code when XMLHttpRequest or XDomainRequest API is not supported.
       * @param {Number} PLUGIN_NOT_AVAILABLE The error code when WebRTC plugin is not active.
       * @param {Number} NO_WEBRTC_SUPPORT The error code when WebRTC is not supported for browser or device.
       * @param {Number} PARSE_CODECS The error code when parsing of WebRTC supports fails.
       * @type JSON
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.INIT_ERROR_CODE_ENUM = {
        NO_SOCKET_IO: 1,
        NO_XMLHTTPREQUEST_SUPPORT: 2,
        NO_WEBRTC_SUPPORT: 3,
        PLUGIN_NOT_AVAILABLE: 4,
        //NO_PATH: 4,
        ADAPTER_NO_LOADED: 7,
        PARSE_CODECS: 8
      };
      
      /**
       * The enum of Room authentication states, in which is used to validate the App Key ID before starting a session.
       * @attribute AUTH_STATE_ENUM
       * @param {Number} LOADING The state when Room is authenticating.
       * @param {Number} COMPLETED The state when Room has been authenticated successfully.
       * @param {Number} ERROR The state when Room failed to authenticate.
       * @type JSON
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.AUTH_STATE_ENUM = {
        LOADING: 1,
        COMPLETED: 2,
        ERROR: -1
      };
      
      /**
       * The enum of Room authentication error codes.
       * @attribute AUTH_ERROR_CODE_ENUM
       * @param {Number} API_INVALID The error code when configured App Key does not exists.
       * @param {Number} API_DOMAIN_NOT_MATCH The error code when App Key &#x60;&quot;domainName&quot;&#x60; setting does not
       *   match accessing server IP address.
       * @param {Number} API_CORS_DOMAIN_NOT_MATCH The error code when App Key &#x60;&quot;corsurl&quot;&#x60; setting does not
       *   match app accessing CORS.
       * @param {Number} API_CREDENTIALS_INVALID The error code when there is no CORS present in the
       *   HTTP headers when required.
       * @param {Number} API_CREDENTIALS_NOT_MATCH The error code when &#x60;.authCreds.hash&#x60; does not match
       *   the Auth (API) server generated hash as part of authentication.
       * @param {Number} API_INVALID_PARENT_KEY The error code when configured App Key does not belong to any active Apps.
       * @param {Number} API_NO_MEETING_RECORD_FOUND The error code when persistent Room enabled App Key does not
       *   have any matching scheduled meetings as matched from the &#x60;.authCreds&#x60; setting.
       * @param {Number} API_OVER_SEAT_LIMIT The error code when App Key has reached its concurrent users limit.
       * @param {Number} API_RETRIEVAL_FAILED The error code when App Key encounters server errors during retrieval.
       * @param {Number} API_WRONG_ACCESS_DOMAIN The error code when &#x60;.server&#x60; is using
       *  &#x60;&quot;https://developer.temasys.com.sg&quot;&#x60; domain to authenticate App Key.
       * @param {Number} XML_HTTP_REQUEST_ERROR The error code when HTTP request failed to receive expected response.
       * @param {Number} NOT_INIT The error code when {{#crossLink &quot;Room/init:method&quot;}}{{/crossLink}} is not called
       *   before attempting {{#crossLink &quot;Room/connect:method&quot;}}{{/crossLink}} method.
       * @type JSON
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.AUTH_ERROR_CODE_ENUM = {
        API_INVALID: 4001,
        API_DOMAIN_NOT_MATCH: 4002,
        API_CORS_DOMAIN_NOT_MATCH: 4003,
        API_CREDENTIALS_INVALID: 4004,
        API_CREDENTIALS_NOT_MATCH: 4005,
        API_INVALID_PARENT_KEY: 4006,
        API_NO_MEETING_RECORD_FOUND: 4010,
        API_OVER_SEAT_LIMIT: 4020,
        API_RETRIEVAL_FAILED: 4021,
        API_WRONG_ACCESS_DOMAIN: 5005,
        XML_HTTP_REQUEST_ERROR: -1,
        NOT_INIT: -2
      };
      
      /**
       * The enum of Room connection session states.
       * @attribute SESSION_STATE_ENUM
       * @param {String} CONNECTING The state when Room connection session is attempting to start.
       * @param {String} CONNECT The state when Room connection session has started.
       * @param {String} REJECT The state when Room connection session was terminated from server.
       * @param {String} WARNING The state when Room connection session is warned which might result in
       *   &#x60;REJECT&#x60; state if not closely followed.
       * @param {String} DISCONNECT The state when Room connection session has ended.
       * @param {String} CONNECT_ERROR The state when Room connection session failed to start due
       *   to socket connection errors.
       * @type JSON
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.SESSION_STATE_ENUM = {
        CONNECTING: &#x27;connecting&#x27;,
        CONNECT: &#x27;connect&#x27;,
        REJECT: &#x27;reject&#x27;,
        WARNING: &#x27;warning&#x27;,
        DISCONNECT: &#x27;disconnect&#x27;,
        CONNECT_ERROR: &#x27;connectError&#x27;
      };
      
      /**
       * The enum of Room connection session error codes.
       * @attribute SESSION_ERROR_ENUM
       * @param {String} CREDENTIALS_EXPIRED The error code when Room connection session failed to start
       *   because session credentials returned from Auth (API) has already expired.
       * @param {String} CREDENTIALS_ERROR The error code when Room connection session failed to start
       *   because session credentials returned from Auth (API) was invalid.
       * @param {String} DUPLICATED_LOGIN The error code when Room connection session failed to start
       *   because session credentials returned from Auth (API) has already been used.
       * @param {String} ROOM_NOT_STARTED The error code when Room connection session failed to start
       *   because session has not yet started based on the provided &#x60;.start&#x60;.
       * @param {String} EXPIRED The error code when Room connection session failed to start because it has already ended.
       * @param {String} ROOM_LOCKED The error code when Room connection session failed to start because the Room is locked.
       * @param {String} FAST_MESSAGE The error code that serves as a warning to current Room connection session
       *   as User is flooding the servers with lots of several socket messages. This might result in the User&#x27;s Room
       *   connection session being terminated and messages sent to be dropped.
       * @param {String} ROOM_CLOSING The error code that serves as a warning to current Room connection session
       *   that the Room session is ending soon.
       * @param {String} ROOM_CLOSED The error code when current Room connection session has ended.
       * @param {String} SERVER_ERROR The error code when Room connection session failed to start
       *   because of internal server exceptions encountered while attempting to start.
       * @param {String} KEY_ERROR The error code when Room connection session failed to start
       *   because of some internal technical error pertaining to App Key initialisation.
       * @type JSON
       * @readOnly
       * @final
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.SESSION_ERROR_ENUM = {
        CREDENTIALS_EXPIRED: &#x27;oldTimeStamp&#x27;,
        CREDENTIALS_ERROR: &#x27;credentialError&#x27;,
        DUPLICATED_LOGIN: &#x27;duplicatedLogin&#x27;,
        ROOM_NOT_STARTED: &#x27;notStart&#x27;,
        EXPIRED: &#x27;expired&#x27;,
        ROOM_LOCKED: &#x27;locked&#x27;,
        FAST_MESSAGE: &#x27;fastmsg&#x27;,
        ROOM_CLOSING: &#x27;toclose&#x27;,
        ROOM_CLOSED: &#x27;roomclose&#x27;,
        SERVER_ERROR: &#x27;serverError&#x27;,
        KEY_ERROR: &#x27;keyFailed&#x27;
      };
      
      /**
       * Function to get and check the connection availability.
       * @method getConnectionAvailability
       * @param {Function} callback 
       */
      Room.prototype.getConnectionAvailability = function () {
        var ref = this;
      
        
      };
      
      /**
       * Function to start initialising Room dependencies.
       * @method init
       * @param {Function} callback The callback function for async code execution.
       *   Returns a format of: &lt;code&gt;function([error])&lt;/code&gt;
       * @param {JSON} [callback.error] The error.
       *   This is only defined if there are errors in code execution.
       *   The object signature matches the {{#crossLink &quot;Room/initState:event&quot;}}{{/crossLink}}
       *   event &#x60;error&#x60; payload parameter.
       * @async
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.init = function (fn) {
        var ref = this;
      
        if (typeof fn === &#x27;function&#x27;) {
          ref.once(&#x27;initState&#x27;, function (state, error) {
            if (error) {
              return fn(error);
            }
            fn(null);
          }, function (state) {
            return [ref.INIT_STATE_ENUM.ERROR, ref.INIT_STATE_ENUM.COMPLETED].indexOf(state) &gt; -1;
          });
        }
      
        var fnUpdate = function (state, error) {
          ref.current.initState = state;
          ref._event.emit(&#x27;initState&#x27;, state, error);
        };
      
        fnUpdate(ref.INIT_STATE_ENUM.LOADING);
      
        // Make sure AdapterJS is loaded
        if (!(globals.AdapterJS &amp;&amp; typeof globals.AdapterJS === &#x27;object&#x27; &amp;&amp;
          globals.AdapterJS.webRTCReady &amp;&amp; typeof globals.AdapterJS.webRTCReady === &#x27;function&#x27;)) {
          return fnUpdate(ref.INIT_STATE_ENUM.ERROR, {
            error: new Error(&#x27;AdapterJS version @@adapterjsVersion is required to be loaded first&#x27;),
            code: ref.INIT_ERROR_CODE_ENUM.ADAPTER_NO_LOADED
          });
        }
      
        // Make sure socket.io-client is loaded
        if (!(globals.io &amp;&amp; typeof globals.io === &#x27;object&#x27; &amp;&amp; typeof globals.io.connect === &#x27;function&#x27;)) {
          return fnUpdate(ref.INIT_STATE_ENUM.ERROR, {
            error: new Error(&#x27;socket.io-client version @@socketioVersion is required to be loaded first&#x27;),
            code: ref.INIT_ERROR_CODE_ENUM.NO_SOCKET_IO
          });
        }
      
        // Make sure XMLHttpRequest is loaded
        if (!window.XMLHttpRequest &amp;&amp; [&#x27;object&#x27;, &#x27;function&#x27;].indexOf(typeof window.XDomainRequest) === -1) {
          return fnUpdate(ref.INIT_STATE_ENUM.ERROR, {
            error: new Error(&#x27;socket.io-client version @@socketioVersion is required to be loaded first&#x27;),
            code: ref.INIT_ERROR_CODE_ENUM.NO_SOCKET_IO
          });
        }
      
        // Start initialising plugin WebRTC functionalities or screensharing overrides
        globals.AdapterJS.webRTCReady(function () {
          var isPluginUnavailableError = false;
          // Check if plugin is available first
          if (window.RTCPeerConnection) {
            if ([&#x27;IE&#x27;, &#x27;safari&#x27;].indexOf(window.webrtcDetectedBrowser) &gt; -1) {
              isPluginUnavailableError = true;
              try {
                var p = new window.RTCPeerConnection(null);
                // IE returns as typeof object
                ref.webrtcSupports.enabled = [&#x27;object&#x27;, &#x27;function&#x27;].indexOf(
                  typeof p.createOffer) &gt; -1 &amp;&amp; p.createOffer !== null;
              } catch (e) {
                ref.webrtcSupports.enabled = false;
              }
            } else {
              ref.webrtcSupports.enabled = true;
            }
          } else {
            ref.webrtcSupports.enabled = true;
          }
      
          if (ref._config.requireWebRTC) {
            return fnUpdate(ref.INIT_STATE_ENUM.ERROR, {
              error: new Error(isPluginUnavailableError ? &#x27;WebRTC plugin is inactive, please activate it&#x27; :
                &#x27;WebRTC is not supported on this browser or device when required&#x27;),
              code: ref.INIT_ERROR_CODE_ENUM[isPluginUnavailableError ? &#x27;PLUGIN_NOT_AVAILABLE&#x27; : &#x27;NO_WEBRTC_SUPPORT&#x27;]
            });
          }
      
          // TODO: Retrieve and parse the codes available..
          if (ref.webrtcSupports.enabled) {
            ref._getCodecsSupport(function (error) {
              if (error) {
                return fnUpdate(ref.INIT_STATE_ENUM.ERROR, {
                  error: error,
                  code: ref.INIT_ERROR_CODE_ENUM.PARSE_CODECS
                });
              }
              fnUpdate(ref.INIT_STATE_ENUM.COMPLETED);
            });
          }
        });
      };
      
      /**
       * Function to start Room session connection.
       * @method connect
       * @param {JSON} [options] The options.
       * @param {String} [options.server] The Auth (API) server domain to connect to.
       *   The default is based on the preset server domain.
       * @param {String} [options.protocol] The Auth (API) server protocol to connect to.
       *   The default is the value of the current accessing &#x60;window.location.protocol&#x60;.
       * @param {JSON} [options.authCreds] The credentials for hash based authentication.
       *   If this is not provided, the Auth (API) server will authenticate by checking if the CORS url
       *   configuration from the App Key matches the CORS domain from accessing app.
       * @param {String} [options.authCreds.start] The starting DateTime stamp in ISO-8601 string for the Room session connection.
       * @param {Number} [options.authCreds.duration] The duration in hours for the Room session connection.
       *   The maximum duration is &#x60;24&#x60; hours.
       * @param {String} [options.authCreds.hash] The base64 encoded HMAC-SHA1 hash generated from the starting
       *   DateTime stamp, duration, Room name and App Key secret.
       *   Please ensure that the string encodes escape characters for URI ready strings.
       * @param {JSON} [options.socket] The socket connecton configuration.
       *   This references the Socket class constructor options.
       * @param {JSON} [options.peer] The Peer connecton configuration.
       *   This references the Peer class constructor options.
       * @param {Function} callback The callback function for async code execution.
       *   Returns a format of: &lt;code&gt;function([error])&lt;/code&gt;
       * @param {JSON} [callback.error] The error.
       *   This is only defined if there are errors in code execution.
       * @param {String} callback.error.eventName The event name that caused the error.
       * @param {JSON} callback.error.error The error.
       *   The object signature matches the event based on the &#x60;error.eventName&#x60;
       *   &#x60;error&#x60; payload parameter or the socket connection error object.
       * @async
       * @for Room
       * @since 0.7.0
       */
      Room.prototype.connect = function (stream, options, fn) {
        var ref = this;
      
        if (typeof options === &#x27;function&#x27;) {
          fn = options;
          options = null;
        }
      
        options = options || {};
      
        ref.server = options.server &amp;&amp; typeof options.server === &#x27;string&#x27; ? options.server : &#x27;api.temasys.io&#x27;;
        ref.protocol = options.protocol &amp;&amp; typeof options.protocol === &#x27;string&#x27; &amp;&amp;
          options.protocol.indexOf(&#x27;:&#x27;) === (options.protocol.length - 1) ? options.protocol : window.location.protocol;
        ref.hash = null;
      
        if (options.authCreds &amp;&amp; typeof options.authCreds === &#x27;object&#x27; &amp;&amp; options.authCreds.hash &amp;&amp;
          typeof options.authCreds.hash === &#x27;string&#x27; &amp;&amp; typeof options.authCreds.duration === &#x27;number&#x27; &amp;&amp;
          options.authCreds.start &amp;&amp; typeof options.authCreds.start === &#x27;string&#x27;) {
          ref.hash = options.authCreds.hash;
          ref.start = options.authCreds.start;
          ref.duration = options.authCreds.duration;
        }
      
        /**
         * Internal function to update and trigger state.
         */
        var isFnTriggered = false;
        var fnUpdate = function (eventName, state, error) {
          ref.current[eventName] = state;
          ref._event.emit(eventName, state, error);
          // Trigger the callback
          if (typeof fn === &#x27;function&#x27; &amp;&amp; !isFnTriggered &amp;&amp; ((eventName === &#x27;sessionState&#x27; &amp;&amp;
            [ref.SESSION_STATE_ENUM.REJECT, ref.SESSION_STATE_ENUM.CONNECT_ERROR].indexOf(state) &gt; -1) ||
            (eventName === &#x27;authState&#x27; &amp;&amp; state === ref.AUTH_STATE_ENUM.ERROR))) {
            isFnTriggered = true;
            fn({
              type: eventName,
              error: error
            });
          }
        };
      
        if (!ref.current.initState) {
          return fnUpdate(&#x27;authState&#x27;, ref.AUTH_STATE_ENUM.ERROR, {
            error: new Error(&#x27;.init() must be called first before .connect()&#x27;),
            code: ref.AUTH_ERROR_CODE_ENUM.NOT_INIT
          });
        }
      
        var xhr = new XMLHttpRequest();
      
        /**
         * Internal function to load XHR response.
         */
        var fnParseResponse = function (evt) {
          var response = JSON.parse(xhr.response || xhr.responseText || &#x27;{}&#x27;);
      
          if (!response.success) {
            return fnUpdate(&#x27;authState&#x27;, ref.READY_STATES.ERROR, {
              httpStatus: xhr.status || -1,
              error: evt.error &amp;&amp; typeof evt.error === &#x27;object&#x27; ? evt.error :
                new Error(response.info || &#x27;HTTP request error timeout&#x27;),
              code: response.error || ref.AUTH_ERROR_CODE_ENUM.XML_HTTP_REQUEST_ERROR
            });
          }
      
          ref.start = response.start;
          ref.duration = response.len;
          ref.id = response.room_key;
          ref.isPrivileged = response.isPrivileged === true;
          ref.autoIntroduce = response.autoIntroduce !== false;
          ref._session = response;
      
          fnUpdate(&#x27;authState&#x27;, ref.AUTH_STATE_ENUM.COMPLETED);
      
          ref._socket = new Socket(options.socket || {}, {
            server: response.ipSigserver,
            httpsPorts: response.httpsPortList,
            httpPorts: response.httpPortList
          });
      
          ref._socket.on(&#x27;message&#x27;, function (message, error, isSelf) {
            if (!isSelf) {
              ref._handleSMProtocol(message, false);
            }
          });
      
          ref._event.emit(&#x27;socket&#x27;, ref._socket);
          ref._socket._connect(function (error) {
            if (error) {
              return fnUpdate(&#x27;sessionState&#x27;, ref.SESSION_STATE_ENUM.ERROR, {
                error: new Error(&#x27;Failed starting socket connection&#x27;),
                code: ref.SESSION_ERROR_ENUM.CONNECT_ERROR
              });
            } else if (typeof fn === &#x27;function&#x27;) {
              ref.once(&#x27;sessionState&#x27;, function (state, error) {
                if (error) {
                  return fn(error);
                }
                fn(null);
              }, function (state, error) {
                return [ref.SESSION_STATE_ENUM.CONNECT, ref.SESSION_STATE_ENUM.REJECT].indexOf(state) &gt; -1;
              });
            }
      
            ref._handleSMProtocol({ type: &#x27;joinRoom&#x27; }, function (error) {
              fnUpdate(&#x27;sessionState&#x27;, ref.SESSION_STATE_ENUM.ERROR, {
                error: new Error(&#x27;Failed sending socket message to start&#x27;),
                code: ref.SESSION_ERROR_ENUM.CONNECT_ERROR
              });
            });
          });
        };
      
        if ([&#x27;object&#x27;, &#x27;function&#x27;].indexOf(window.XDomainRequest) &gt; -1) {
          xhr = new XDomainRequest();
        }
      
        xhr.onload = fnParseResponse;
        xhr.onerror = fnParseResponse;
      
        xhr.open(&#x27;GET&#x27;, ref.protocol + &#x27;//&#x27; + ref.server + &#x27;/api/&#x27; + ref.appKey + &#x27;/&#x27; + ref.name + (ref.hash ?
          &#x27;/&#x27; + ref.start + &#x27;/&#x27; + ref.duration + &#x27;?&amp;cred=&#x27; + ref.hash + &#x27;&amp;rand=&#x27; + Date.now() : &#x27;?&amp;rand=&#x27; + Date.now()), true);
        xhr.send();
      };
      
      /**
       * Function to update the default stream or self Peer data.
       * @method update
       * @param 
      
      /**
       * Function to parse and retrieve codecs support.
       */
      Room.prototype._getCodecsSupport = function (fn) {
        var ref = this;
      
        ref.webrtcSupports.audioCodecs = {};
        ref.webrtcSupports.videoCodecs = {};
        ref.webrtcSupports.dataChannel = false;
      
        if (!ref.webrtcSupports.enabled) {
          if (ref._config.requireWebRTC) {
            return fn(new Error(&#x27;WebRTC is not supported on this browser or device when required&#x27;));
          }
          return fn(null);
        }
      
        try {
          if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
            Utils.forEach(window.RTCRtpSender.getCapabilities().codecs, function (codec) {
              if ([&#x27;audio&#x27;,&#x27;video&#x27;].indexOf(codec.kind) &gt; -1 &amp;&amp; codec.name) {
                ref.webrtcSupports[codec.kind === &#x27;audio&#x27; ? &#x27;audioCodecs&#x27; : &#x27;videoCodecs&#x27;][
                  codec.name.toLowerCase()] = codec.clockRate + (codec.kind === &#x27;audio&#x27; ?
                  &#x27;/&#x27; + (codecs[i].numChannels &gt; 1 ? codecs[i].numChannels : 1) : &#x27;&#x27;);
              }
            });
            return fn(null);
          }
      
          var pc = new RTCPeerConnection(null);
          var channel = pc.createDataChannel(&#x27;test&#x27;);
      
          ref.webrtcSupports.dataChannel = true;
          ref.webrtcSupports.dataChannelBinaryType = channel.binaryType &amp;&amp; typeof channel.binaryType === &#x27;string&#x27; ?
            (channel.binaryType.indexOf(&#x27;array&#x27;) &gt; -1 ? &#x27;arraybuffer&#x27; : channel.binaryType) : null;
      
          pc.createOffer(function (offer) {
            var mediaType = &#x27;&#x27;;
            Utils.forEach(offer.sdp.split(&#x27;\r\n&#x27;), function (line) {
              if (line.indexOf(&#x27;m=&#x27;) === 0) {
                mediaType = (line.split(&#x27;m=&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0];
                return;
              } else if (mediaType &amp;&amp; [&#x27;audio&#x27;, &#x27;video&#x27;].indexOf(mediaType) &gt; -1 &amp;&amp; line.indexOf(&#x27;a=rtpmap:&#x27;) === 0) {
                var parts = (line.split(&#x27; &#x27;)[1] || &#x27;&#x27;).split(&#x27;/&#x27;);
                ref.webrtcSupports.audioCodecs[parts[0].toLowerCase()] = parts[1] + (mediaType === &#x27;audio&#x27; ?
                  (parts[2] ? &#x27;/&#x27; + parts[2] : 1) : &#x27;&#x27;);
              }
            });
          }, fn, [&#x27;IE&#x27;, &#x27;safari&#x27;].indexOf(window.webrtcDetectedBrowser) &gt; -1 ? {
            mandatory: { OfferToReceiveVideo: true, OfferToReceiveAudio: true }
          } : { offerToReceiveAudio: true, offerToReceiveVideo: true });
      
        } catch (error) {
          fn(error);
        }
      };
      
      /**
       * Function to handle SM protocol for sending direction.
       */
      Room.prototype._constructProtocolMessage = function (params, fn) {
        var ref = this;
        var message = {
          type: params.type,
          rid: ref.id
        };
      
        /**
         * &quot;joinRoom&quot; - Connects to the Room.
         */
        if (params.type === &#x27;joinRoom&#x27;) {
          message.uid = ref._session.username;
          message.apiOwner = ref._session.apiOwner;
          message.cid = ref._session.cid;
          message.isPrivileged = ref.isPrivileged;
          message.autoIntroduce = ref.autoIntroduce;
          message.key = ref.appKey;
          message.len = ref._session.len;
          message.roomCred = ref._session.roomCred;
          message.start = ref._session.start;
          message.timeStamp = ref._session.timeStamp;
          message.userCred = ref._session.userCred;
      
        /**
         * &quot;enter&quot; - Broadcasts to existing Peers in the Room we exist.
         * &quot;welcome&quot; - Respond to Peer who sent &quot;enter&quot; about who we are.
         * &quot;restart&quot; - Re-negotiation request.
         */
        } else if ([&#x27;enter&#x27;, &#x27;welcome&#x27;, &#x27;restart&#x27;].indexOf(params.type)) {
          message.mid = ref.user.id;
          message.
        }
      };
      
      /**
       * Function to handle SM protocol for receiving direction.
       */
      Room.prototype._processProtocolMessage = function (message) {
      
      };
      
      
      
        /**
         * SM protocol: &quot;joinRoom&quot;
         */
        if (params.type === &#x27;joinRoom&#x27;) {
          fnSend({
            type: &#x27;joinRoom&#x27;,
      
          });
        /**
         * SM protocol: &quot;inRoom&quot;
         */
        } else if (params.type === &#x27;inRoom&#x27;) {
          ref.current.peerId = params.sid;
          ref.current.peerPriorityWeight =
          ref._config.iceServers = params.pc_config.iceServers;
          // Broadcast &quot;enter&quot; if auto-introduce is enabled
          if (ref.autoIntroduce) {
            ref._handleSMProtocol({
              type: &#x27;enter&#x27;
            });
          }
        /**
         * SM protocol: &quot;enter&quot;
         */
        } else if ([&#x27;welcome&#x27;, &#x27;restart&#x27;, &#x27;enter&#x27;].indexOf(params.type) &gt; -1) {
          if (fn) {
            fnSend({
              type: params.type,
              agent: window.webrtcDetectedBrowser,
              version: (window.webrtcDetectedVersion || 0).toString(),
              os: window.navigator.platform,
              userInfo: self._getUserInfo(),
              receiveOnly: !ref._stream,
              weight: self._peerPriorityWeight,
              temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,
              enableIceTrickle: self._enableIceTrickle,
              enableDataChannel: self._enableDataChannel,
              enableIceRestart: self._enableIceRestart,
              SMProtocolVersion: self.SM_PROTOCOL_VERSION,
              DTProtocolVersion: self.DT_PROTOCOL_VERSION
            });
          } else {
      
          }
        }
      
        if (isSelf) {
      
        }
      
        if (isSend) {
          if (type === &#x27;joinRoom&#x27; &amp;&amp; ref._creds) {
            message.uid = ref._creds.username;
            message.apiOwner = ref._creds.apiOwner;
            message.cid = ref._creds.cid;
            message.isPrivileged = ref._creds.isPrivileged === true;
            message.autoIntroduce = ref._creds.autoIntroduce !== false;
            message.key = ref.appKey;
            message.len = ref._creds.len;
            message.roomCred = ref._creds.roomCred;
            message.start = ref._creds.start;
            message.timeStamp = ref._creds.timeStamp;
            message.userCred = ref._creds.userCred;
            message.rid = ref.id;
            message.type = type;
          } else if (type === &#x27;welcome&#x27; || type === &#x27;enter&#x27;) {
            message.rid = ref.id;
            message.mid = ref.session.id;
            message.type = type;
          }
          console.info(type, message);
          if (ref._socket) {
            ref._socket._send(message);
          }
        } else {
          if (type === &#x27;group&#x27;) {
            message.lists.forEach(function (itemMsgStr) {
              ref._processSMProtocol(JSON.parse(itemMsgStr));
            });
          } else if (type === &#x27;inRoom&#x27;) {
            ref.session.id = message.sid;
            ref._processSMProtocol(&#x27;enter&#x27;, {}, true);
          } else if (type === &#x27;enter&#x27;) {
            ref._peers[message.mid] = message;
            ref._processSMProtocol(&#x27;welcome&#x27;, {
              target: message.mid
            }, true);
          } else if (type === &#x27;welcome&#x27;) {
            ref._peers[message.mid] = message;
          }
        }
      };
      
      globals.Room = Room;
      
          </pre>
      </div>
    </div>
   </section>
</body>
</html>

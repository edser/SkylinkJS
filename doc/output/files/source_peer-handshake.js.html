<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Temasys Web SDK Documentation (0.6.19)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="name" content="skylinkjs">
  <meta name="version" content="0.6.19">
  <!-- Favicon -->
  <link href="../assets/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
  <link href="../assets/vendor/font-awesome.min.css" rel="stylesheet" type="text/css">
  <!-- Styles -->
  <link href="../assets/vendor/prettify.min.css" rel="stylesheet" type="text/css">
  <link href="../assets/css/main.css" rel="stylesheet" type="text/css">
  <script src="../assets/vendor/jquery.min.js" type="text/javascript"></script>
  <script src="../assets/vendor/prettify.min.js" type="text/javascript"></script>
  <script src="../assets/js/main.js" type="text/javascript"></script>
</head>
<body>
  <!-- Navigation Header -->
  <navbar class="top">
    <a class="main" href="/">
      <img src="../assets/img/favicon.ico">
      <strong>Temasys</strong> Web SDK
    </a>
    <ul class="menu">
      <li><a href="https://github.com/Temasys/SkylinkJS" target="_blank">SkylinkJS Github</a></li>
      <li><a href="https://console.temasys.io/" target="_blank">Developer Console</a></li>
    </ul>
  </navbar>

  <!-- Body -->
  <section class="container">
    <div class="container-wrapper">
      <!-- Side Navigation -->
      <navbar class="side">
        <div id="side-menu" class="navbar-wrapper">
          <ul class="menu">
            <div class="section">
              <span class="header">Getting Started</span>    
              <li>
              <a href="#">1. Overview <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Architecture</a></li>
                  <li><a href="#">b. Authentication Methods</a></li>
                  <li><a href="#">c. Persistent Rooms</a></li>
                  <li><a href="#">d. Auto-Introduce & Privileged</a></li>
              </ul>
              </li>
              <li>
              <a href="#">2. Integrating to Your Site <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Referencing the SDK</a></li>
                  <li><a href="#">b. Code Samples</a></li>
                  <li><a href="#">c. Integrating your extensions & WebRTC plugin</a></li>
              </ul>
              </li>
              <li><a href="#" class="nodropdown">3. Demos</a></li>
            </div>
            <div class="section">
              <span class="header">API Documentation</span>
              <li>
                <a href="#">Temasys <small>module</small><i class="fa fa-caret-down"></i></a>
                <ul>
                </ul>
              </li>
                  ([&quot;Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Room.html" class="nodropdown">
                      Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Skylink&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Skylink.html" class="nodropdown">
                      Skylink <small>class</small>
                    </a>
                  </li>
                  ([&quot;Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Socket.html" class="nodropdown">
                      Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Peer&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Peer.html" class="nodropdown">
                      Temasys.Peer <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Room.html" class="nodropdown">
                      Temasys.Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Socket.html" class="nodropdown">
                      Temasys.Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Utils.html" class="nodropdown">
                      Temasys.Utils <small>class</small>
                    </a>
                  </li>
                  ([&quot;Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Utils.html" class="nodropdown">
                      Utils <small>class</small>
                    </a>
                  </li>
            </div>
          </ul>
        </div>
      </navbar>      <!-- Content -->
      <h1 class="file-heading">File: source/peer-handshake.js</h1>
      
      <div class="file">
          <pre class="code prettyprint linenums">
      /**
       * The list of Peer connection states.
       * @attribute HANDSHAKE_PROGRESS
       * @param {String} ENTER   &lt;small&gt;Value &lt;code&gt;&quot;enter&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the connection state when Peer has just entered the Room.
       *   &lt;small&gt;At this stage, &lt;a href=&quot;#event_peerJoined&quot;&gt;&lt;code&gt;peerJoined&lt;/code&gt; event&lt;/a&gt;
       *   is triggered.&lt;/small&gt;
       * @param {String} WELCOME &lt;small&gt;Value &lt;code&gt;&quot;welcome&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the connection state when Peer is aware that User has entered the Room.
       *   &lt;small&gt;At this stage, &lt;a href=&quot;#event_peerJoined&quot;&gt;&lt;code&gt;peerJoined&lt;/code&gt; event&lt;/a&gt;
       *   is triggered and Peer connection may commence.&lt;/small&gt;
       * @param {String} OFFER   &lt;small&gt;Value &lt;code&gt;&quot;offer&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the connection state when Peer connection has set the local / remote &lt;code&gt;&quot;offer&quot;&lt;/code&gt;
       *   session description to start streaming connection.
       * @param {String} ANSWER  &lt;small&gt;Value &lt;code&gt;&quot;answer&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the connection state when Peer connection has set the local / remote &lt;code&gt;&quot;answer&quot;&lt;/code&gt;
       *   session description to establish streaming connection.
       * @param {String} ERROR   &lt;small&gt;Value &lt;code&gt;&quot;error&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the connection state when Peer connection has failed to establish streaming connection.
       *   &lt;small&gt;This happens when there are errors that occurs in creating local &lt;code&gt;&quot;offer&quot;&lt;/code&gt; /
       *   &lt;code&gt;&quot;answer&quot;&lt;/code&gt;, or when setting remote / local &lt;code&gt;&quot;offer&quot;&lt;/code&gt; / &lt;code&gt;&quot;answer&quot;&lt;/code&gt;.&lt;/small&gt;
       * @type JSON
       * @readOnly
       * @for Skylink
       * @since 0.1.0
       */
      Skylink.prototype.HANDSHAKE_PROGRESS = {
        ENTER: &#x27;enter&#x27;,
        WELCOME: &#x27;welcome&#x27;,
        OFFER: &#x27;offer&#x27;,
        ANSWER: &#x27;answer&#x27;,
        ERROR: &#x27;error&#x27;
      };
      
      /**
       * Function that creates the Peer connection offer session description.
       * @method _doOffer
       * @private
       * @for Skylink
       * @since 0.5.2
       */
      Skylink.prototype._doOffer = function(targetMid, iceRestart, peerBrowser) {
        var self = this;
        var pc = self._peerConnections[targetMid];// || self._addPeer(targetMid, peerBrowser);
      
        log.log([targetMid, null, null, &#x27;Checking caller status&#x27;], peerBrowser);
      
        // Added checks to ensure that connection object is defined first
        if (!pc) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, &#x27;offer&#x27;, &#x27;Dropping of creating of offer &#x27; +
            &#x27;as connection does not exists&#x27;]);
          return;
        }
      
        // Added checks to ensure that state is &quot;stable&quot; if setting local &quot;offer&quot;
        if (pc.signalingState !== self.PEER_CONNECTION_STATE.STABLE) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, &#x27;offer&#x27;,
            &#x27;Dropping of creating of offer as signalingState is not &quot;&#x27; +
            self.PEER_CONNECTION_STATE.STABLE + &#x27;&quot; -&gt;&#x27;], pc.signalingState);
          return;
        }
      
        var peerAgent = ((self._peerInformations[targetMid] || {}).agent || {}).name || &#x27;&#x27;;
        var doIceRestart = !!((self._peerInformations[targetMid] || {}).config || {}).enableIceRestart &amp;&amp;
          iceRestart &amp;&amp; self._enableIceRestart;
        var offerToReceiveAudio = !(!self._sdpSettings.connection.audio &amp;&amp; targetMid !== &#x27;MCU&#x27;);
        var offerToReceiveVideo = !(!self._sdpSettings.connection.video &amp;&amp; targetMid !== &#x27;MCU&#x27;) &amp;&amp;
          ((window.webrtcDetectedBrowser === &#x27;edge&#x27; &amp;&amp; peerAgent !== &#x27;edge&#x27;) ||
          ([&#x27;IE&#x27;, &#x27;safari&#x27;].indexOf(window.webrtcDetectedBrowser) &gt; -1 &amp;&amp; peerAgent === &#x27;edge&#x27;) ?
          !!self._currentCodecSupport.video.h264 : true);
      
        var offerConstraints = {
          offerToReceiveAudio: offerToReceiveAudio,
          offerToReceiveVideo: offerToReceiveVideo,
          iceRestart: doIceRestart,
          voiceActivityDetection: self._voiceActivityDetection
        };
      
        // Prevent undefined OS errors
        peerBrowser.os = peerBrowser.os || &#x27;&#x27;;
      
        // Fallback to use mandatory constraints for plugin based browsers
        if ([&#x27;IE&#x27;, &#x27;safari&#x27;].indexOf(window.webrtcDetectedBrowser) &gt; -1) {
          offerConstraints = {
            mandatory: {
              OfferToReceiveAudio: offerToReceiveAudio,
              OfferToReceiveVideo: offerToReceiveVideo,
              iceRestart: doIceRestart,
              voiceActivityDetection: self._voiceActivityDetection
            }
          };
        }
      
        // Add stream only at offer/answer end
        if (!self._hasMCU || targetMid === &#x27;MCU&#x27;) {
          self._addLocalMediaStreams(targetMid);
        }
      
        if (self._enableDataChannel &amp;&amp; self._peerInformations[targetMid] &amp;&amp;
          self._peerInformations[targetMid].config.enableDataChannel &amp;&amp;
          !(!self._sdpSettings.connection.data &amp;&amp; targetMid !== &#x27;MCU&#x27;)) {
          // Edge doesn&#x27;t support datachannels yet
          if (!(self._dataChannels[targetMid] &amp;&amp; self._dataChannels[targetMid].main)) {
            self._createDataChannel(targetMid);
            self._peerConnections[targetMid].hasMainChannel = true;
          }
        }
      
        log.debug([targetMid, null, null, &#x27;Creating offer with config:&#x27;], offerConstraints);
      
        pc.endOfCandidates = false;
      
        pc.createOffer(function(offer) {
          log.debug([targetMid, null, null, &#x27;Created offer&#x27;], offer);
      
          self._setLocalAndSendMessage(targetMid, offer);
      
        }, function(error) {
          self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
      
          log.error([targetMid, null, null, &#x27;Failed creating an offer:&#x27;], error);
      
        }, offerConstraints);
      };
      
      /**
       * Function that creates the Peer connection answer session description.
       * This comes after receiving and setting the offer session description.
       * @method _doAnswer
       * @private
       * @for Skylink
       * @since 0.1.0
       */
      Skylink.prototype._doAnswer = function(targetMid) {
        var self = this;
        log.log([targetMid, null, null, &#x27;Creating answer with config:&#x27;],
          self._room.connection.sdpConstraints);
        var pc = self._peerConnections[targetMid];
      
        // Added checks to ensure that connection object is defined first
        if (!pc) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, &#x27;answer&#x27;, &#x27;Dropping of creating of answer &#x27; +
            &#x27;as connection does not exists&#x27;]);
          return;
        }
      
        // Added checks to ensure that state is &quot;have-remote-offer&quot; if setting local &quot;answer&quot;
        if (pc.signalingState !== self.PEER_CONNECTION_STATE.HAVE_REMOTE_OFFER) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, &#x27;answer&#x27;,
            &#x27;Dropping of creating of answer as signalingState is not &quot;&#x27; +
            self.PEER_CONNECTION_STATE.HAVE_REMOTE_OFFER + &#x27;&quot; -&gt;&#x27;], pc.signalingState);
          return;
        }
      
        // Add stream only at offer/answer end
        if ((!self._hasMCU || targetMid === &#x27;MCU&#x27;) &amp;&amp; window.webrtcDetectedBrowser !== &#x27;edge&#x27;) {
          self._addLocalMediaStreams(targetMid);
        }
      
        var peerAgent = ((self._peerInformations[targetMid] || {}).agent || {}).name || &#x27;&#x27;;
        var offerToReceiveAudio = !(!self._sdpSettings.connection.audio &amp;&amp; targetMid !== &#x27;MCU&#x27;);
        var offerToReceiveVideo = !(!self._sdpSettings.connection.video &amp;&amp; targetMid !== &#x27;MCU&#x27;) &amp;&amp;
          ((window.webrtcDetectedBrowser === &#x27;edge&#x27; &amp;&amp; peerAgent !== &#x27;edge&#x27;) ||
          ([&#x27;IE&#x27;, &#x27;safari&#x27;].indexOf(window.webrtcDetectedBrowser) &gt; -1 &amp;&amp; peerAgent === &#x27;edge&#x27;) ?
          !!self._currentCodecSupport.video.h264 : true);
      
        // No ICE restart constraints for createAnswer as it fails in chrome 48
        // { iceRestart: true }
        pc.createAnswer(function(answer) {
          log.debug([targetMid, null, null, &#x27;Created answer&#x27;], answer);
          self._setLocalAndSendMessage(targetMid, answer);
        }, function(error) {
          log.error([targetMid, null, null, &#x27;Failed creating an answer:&#x27;], error);
          self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
        }, window.webrtcDetectedBrowser === &#x27;edge&#x27; ? {
          offerToReceiveVideo: offerToReceiveVideo,
          offerToReceiveAudio: offerToReceiveAudio,
          voiceActivityDetection: self._voiceActivityDetection
        } : undefined);
      };
      
      /**
       * Function that sets the local session description and sends to Peer.
       * If trickle ICE is disabled, the local session description will be sent after
       *   ICE gathering has been completed.
       * @method _setLocalAndSendMessage
       * @private
       * @for Skylink
       * @since 0.5.2
       */
      Skylink.prototype._setLocalAndSendMessage = function(targetMid, sessionDescription) {
        var self = this;
        var pc = self._peerConnections[targetMid];
      
        // Added checks to ensure that sessionDescription is defined first
        if (!(!!sessionDescription &amp;&amp; !!sessionDescription.sdp)) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, null, &#x27;Local session description is undefined -&gt;&#x27;], sessionDescription);
          return;
        }
      
        // Added checks to ensure that connection object is defined first
        if (!pc) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type,
            &#x27;Local session description will not be set as connection does not exists -&gt;&#x27;], sessionDescription);
          return;
      
        } else if (sessionDescription.type === self.HANDSHAKE_PROGRESS.OFFER &amp;&amp;
          pc.signalingState !== self.PEER_CONNECTION_STATE.STABLE) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type, &#x27;Local session description &#x27; +
            &#x27;will not be set as signaling state is &quot;&#x27; + pc.signalingState + &#x27;&quot; -&gt;&#x27;], sessionDescription);
          return;
      
        // Added checks to ensure that state is &quot;have-remote-offer&quot; if setting local &quot;answer&quot;
        } else if (sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER &amp;&amp;
          pc.signalingState !== self.PEER_CONNECTION_STATE.HAVE_REMOTE_OFFER) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type, &#x27;Local session description &#x27; +
            &#x27;will not be set as signaling state is &quot;&#x27; + pc.signalingState + &#x27;&quot; -&gt;&#x27;], sessionDescription);
          return;
      
        // Added checks if there is a current local sessionDescription being processing before processing this one
        } else if (pc.processingLocalSDP) {
          log.warn([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type,
            &#x27;Local session description will not be set as another is being processed -&gt;&#x27;], sessionDescription);
          return;
        }
      
        pc.processingLocalSDP = true;
      
        // Set them as first
        if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
          sessionDescription.sdp = self._setSDPCodec(targetMid, sessionDescription, {
            audio: self.AUDIO_CODEC.OPUS,
            video: self.VIDEO_CODEC.H264
          });
        }
      
        // Sets and expected receiving codecs etc.
        sessionDescription.sdp = self._removeSDPFirefoxH264Pref(targetMid, sessionDescription);
        sessionDescription.sdp = self._setSDPCodecParams(targetMid, sessionDescription);
        sessionDescription.sdp = self._removeSDPUnknownAptRtx(targetMid, sessionDescription);
        sessionDescription.sdp = self._removeSDPCodecs(targetMid, sessionDescription);
        sessionDescription.sdp = self._handleSDPConnectionSettings(targetMid, sessionDescription, &#x27;local&#x27;);
        sessionDescription.sdp = self._removeSDPREMBPackets(targetMid, sessionDescription);
      
        log.log([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type,
          &#x27;Local session description updated -&gt;&#x27;], sessionDescription.sdp);
      
        pc.setLocalDescription(sessionDescription, function() {
          log.debug([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type,
            &#x27;Local session description has been set -&gt;&#x27;], sessionDescription);
      
          pc.processingLocalSDP = false;
      
          self._trigger(&#x27;handshakeProgress&#x27;, sessionDescription.type, targetMid);
      
          if (sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER) {
            pc.setAnswer = &#x27;local&#x27;;
          } else {
            pc.setOffer = &#x27;local&#x27;;
          }
      
          if (!self._enableIceTrickle &amp;&amp; !pc.gathered) {
            log.log([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type,
              &#x27;Local session description sending is halted to complete ICE gathering.&#x27;]);
            return;
          }
      
          self._sendChannelMessage({
            type: sessionDescription.type,
            sdp: self._addSDPMediaStreamTrackIDs(targetMid, sessionDescription),
            mid: self._user.sid,
            target: targetMid,
            rid: self._room.id,
            userInfo: self._getUserInfo(targetMid)
          });
      
        }, function(error) {
          log.error([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type, &#x27;Local description failed setting -&gt;&#x27;], error);
      
          pc.processingLocalSDP = false;
      
          self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
        });
      };
      
          </pre>
      </div>
    </div>
   </section>
</body>
</html>

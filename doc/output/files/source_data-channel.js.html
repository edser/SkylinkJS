<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Temasys Web SDK Documentation (0.6.19)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="name" content="skylinkjs">
  <meta name="version" content="0.6.19">
  <!-- Favicon -->
  <link href="../assets/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
  <link href="../assets/vendor/font-awesome.min.css" rel="stylesheet" type="text/css">
  <!-- Styles -->
  <link href="../assets/vendor/prettify.min.css" rel="stylesheet" type="text/css">
  <link href="../assets/css/main.css" rel="stylesheet" type="text/css">
  <script src="../assets/vendor/jquery.min.js" type="text/javascript"></script>
  <script src="../assets/vendor/prettify.min.js" type="text/javascript"></script>
  <script src="../assets/js/main.js" type="text/javascript"></script>
</head>
<body>
  <!-- Navigation Header -->
  <navbar class="top">
    <a class="main" href="/">
      <img src="../assets/img/favicon.ico">
      <strong>Temasys</strong> Web SDK
    </a>
    <ul class="menu">
      <li><a href="https://github.com/Temasys/SkylinkJS" target="_blank">SkylinkJS Github</a></li>
      <li><a href="https://console.temasys.io/" target="_blank">Developer Console</a></li>
    </ul>
  </navbar>

  <!-- Body -->
  <section class="container">
    <div class="container-wrapper">
      <!-- Side Navigation -->
      <navbar class="side">
        <div id="side-menu" class="navbar-wrapper">
          <ul class="menu">
            <div class="section">
              <span class="header">Getting Started</span>    
              <li>
              <a href="#">1. Overview <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Architecture</a></li>
                  <li><a href="#">b. Authentication Methods</a></li>
                  <li><a href="#">c. Persistent Rooms</a></li>
                  <li><a href="#">d. Auto-Introduce & Privileged</a></li>
              </ul>
              </li>
              <li>
              <a href="#">2. Integrating to Your Site <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Referencing the SDK</a></li>
                  <li><a href="#">b. Code Samples</a></li>
                  <li><a href="#">c. Integrating your extensions & WebRTC plugin</a></li>
              </ul>
              </li>
              <li><a href="#" class="nodropdown">3. Demos</a></li>
            </div>
            <div class="section">
              <span class="header">API Documentation</span>
              <li>
                <a href="#">Temasys <small>module</small><i class="fa fa-caret-down"></i></a>
                <ul>
                </ul>
              </li>
                  ([&quot;Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Room.html" class="nodropdown">
                      Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Skylink&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Skylink.html" class="nodropdown">
                      Skylink <small>class</small>
                    </a>
                  </li>
                  ([&quot;Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Socket.html" class="nodropdown">
                      Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.html" class="nodropdown">
                      Temasys <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Datachannel&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Datachannel.html" class="nodropdown">
                      Temasys.Datachannel <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Peer&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Peer.html" class="nodropdown">
                      Temasys.Peer <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Room.html" class="nodropdown">
                      Temasys.Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Socket.html" class="nodropdown">
                      Temasys.Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Stream&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Stream.html" class="nodropdown">
                      Temasys.Stream <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Utils.html" class="nodropdown">
                      Temasys.Utils <small>class</small>
                    </a>
                  </li>
            </div>
          </ul>
        </div>
      </navbar>      <!-- Content -->
      <h1 class="file-heading">File: source/data-channel.js</h1>
      
      <div class="file">
          <pre class="code prettyprint linenums">
      /**
       * The list of Datachannel connection states.
       * @attribute DATA_CHANNEL_STATE
       * @param {String} CONNECTING          &lt;small&gt;Value &lt;code&gt;&quot;connecting&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel is attempting to establish a connection.
       * @param {String} OPEN                &lt;small&gt;Value &lt;code&gt;&quot;open&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel has established a connection.
       * @param {String} CLOSING             &lt;small&gt;Value &lt;code&gt;&quot;closing&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel connection is closing.
       * @param {String} CLOSED              &lt;small&gt;Value &lt;code&gt;&quot;closed&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel connection has closed.
       * @param {String} ERROR               &lt;small&gt;Value &lt;code&gt;&quot;error&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel has encountered an exception during connection.
       * @param {String} CREATE_ERROR        &lt;small&gt;Value &lt;code&gt;&quot;createError&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel has failed to establish a connection.
       * @param {String} BUFFERED_AMOUNT_LOW &lt;small&gt;Value &lt;code&gt;&quot;bufferedAmountLow&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel when the amount of data buffered to be sent
       *   falls below the Datachannel threshold.
       *   &lt;small&gt;This state should occur only during after &lt;a href=&quot;#method_sendBlobData&quot;&gt;
       *   &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; or &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; or
       *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
       * @param {String} SEND_MESSAGE_ERROR  &lt;small&gt;Value &lt;code&gt;&quot;sendMessageError&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the state when Datachannel when data transfer packets or P2P message fails to send.
       *   &lt;small&gt;This state should occur only during after &lt;a href=&quot;#method_sendBlobData&quot;&gt;
       *   &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; or &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; or
       *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
       * @type JSON
       * @readOnly
       * @for Skylink
       * @since 0.1.0
       */
      Skylink.prototype.DATA_CHANNEL_STATE = {
        CONNECTING: &#x27;connecting&#x27;,
        OPEN: &#x27;open&#x27;,
        CLOSING: &#x27;closing&#x27;,
        CLOSED: &#x27;closed&#x27;,
        ERROR: &#x27;error&#x27;,
        CREATE_ERROR: &#x27;createError&#x27;,
        BUFFERED_AMOUNT_LOW: &#x27;bufferedAmountLow&#x27;,
        SEND_MESSAGE_ERROR: &#x27;sendMessageError&#x27;
      };
      
      /**
       * The list of Datachannel types.
       * @attribute DATA_CHANNEL_TYPE
       * @param {String} MESSAGING &lt;small&gt;Value &lt;code&gt;&quot;messaging&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the Datachannel type that is used only for messaging in
       *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.
       *   &lt;small&gt;However for Peers that do not support simultaneous data transfers, this Datachannel
       *   type will be used to do data transfers (1 at a time).&lt;/small&gt;
       *   &lt;small&gt;Each Peer connections will only have one of this Datachannel type and the
       *   connection will only close when the Peer connection is closed (happens when &lt;a href=&quot;#event_peerConnectionState&quot;&gt;
       *   &lt;code&gt;peerConnectionState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as
       *   &lt;code&gt;CLOSED&lt;/code&gt; for Peer).&lt;/small&gt;
       * @param {String} DATA &lt;small&gt;Value &lt;code&gt;&quot;data&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the Datachannel type that is used only for a data transfer in
       *   &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; and
       *   &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;.
       *   &lt;small&gt;The connection will close after the data transfer has been completed or terminated (happens when
       *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
       *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;DOWNLOAD_COMPLETED&lt;/code&gt;, &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt;,
       *   &lt;code&gt;REJECTED&lt;/code&gt;, &lt;code&gt;CANCEL&lt;/code&gt; or &lt;code&gt;ERROR&lt;/code&gt; for Peer).&lt;/small&gt;
       * @type JSON
       * @readOnly
       * @for Skylink
       * @since 0.6.1
       */
      Skylink.prototype.DATA_CHANNEL_TYPE = {
        MESSAGING: &#x27;messaging&#x27;,
        DATA: &#x27;data&#x27;
      };
      
      /**
       * The list of Datachannel sending message error types.
       * @attribute DATA_CHANNEL_MESSAGE_ERROR
       * @param {String} MESSAGE  &lt;small&gt;Value &lt;code&gt;&quot;message&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the Datachannel sending message error type when encountered during
       *   sending P2P message from &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.
       * @param {String} TRANSFER &lt;small&gt;Value &lt;code&gt;&quot;transfer&quot;&lt;/code&gt;&lt;/small&gt;
       *   The value of the Datachannel sending message error type when encountered during
       *   data transfers from &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; or
       *   &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;.
       * @type JSON
       * @readOnly
       * @for Skylink
       * @since 0.6.16
       */
      Skylink.prototype.DATA_CHANNEL_MESSAGE_ERROR = {
        MESSAGE: &#x27;message&#x27;,
        TRANSFER: &#x27;transfer&#x27;
      };
      
      /**
       * Function that starts a Datachannel connection with Peer.
       * @method _createDataChannel
       * @private
       * @for Skylink
       * @since 0.5.5
       */
      Skylink.prototype._createDataChannel = function(peerId, dataChannel, bufferThreshold, createAsMessagingChannel) {
        var self = this;
        var channelName = (self._user &amp;&amp; self._user.sid ? self._user.sid : &#x27;-&#x27;) + &#x27;_&#x27; + peerId;
        var channelType = createAsMessagingChannel ? self.DATA_CHANNEL_TYPE.MESSAGING : self.DATA_CHANNEL_TYPE.DATA;
        var channelProp = channelType === self.DATA_CHANNEL_TYPE.MESSAGING ? &#x27;main&#x27; : channelName;
      
        if (!self._user) {
          log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
            &#x27;Aborting of creating or initializing Datachannel as User does not have Room session&#x27;]);
          return;
        }
      
        if (!(self._peerConnections[peerId] &amp;&amp;
          self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED)) {
          log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
            &#x27;Aborting of creating or initializing Datachannel as Peer connection does not exists&#x27;]);
          return;
        }
      
      
        if (dataChannel &amp;&amp; typeof dataChannel === &#x27;object&#x27;) {
          channelName = dataChannel.label;
      
        } else if (typeof dataChannel === &#x27;string&#x27;) {
          channelName = dataChannel;
          dataChannel = null;
        }
      
        if (!dataChannel) {
          try {
            dataChannel = self._peerConnections[peerId].createDataChannel(channelName, {
              reliable: true,
              ordered: true
            });
      
          } catch (error) {
            log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Failed creating Datachannel -&gt;&#x27;], error);
            self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.CREATE_ERROR, peerId, error, channelName,
              channelType, null, self._getDataChannelBuffer(dataChannel));
            return;
          }
        }
      
        if (!self._dataChannels[peerId]) {
          channelProp = &#x27;main&#x27;;
          channelType = self.DATA_CHANNEL_TYPE.MESSAGING;
          self._dataChannels[peerId] = {};
          log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;initializing main DataChannel&#x27;]);
        } else if (self._dataChannels[peerId].main &amp;&amp; self._dataChannels[peerId].main.channel.label === channelName) {
          channelProp = &#x27;main&#x27;;
          channelType = self.DATA_CHANNEL_TYPE.MESSAGING;
        }
      
        var channel = new Datachannel(dataChannel, peerId, channelProp);
      
        channel.on(&#x27;state&#x27;, function (state) {
          self._trigger(&#x27;dataChannelState&#x27;, state, peerId, null, channelName, channelType, null, channel.getStats());
        });
      
        channel.on(&#x27;error&#x27;, function (error) {
          var bufferAmount = channel.getStats();
          self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.ERROR, peerId, error,
            channelName, channelType, null, bufferAmount);
        });
      
        channel.on(&#x27;bufferedamountlow&#x27;, function (error) {
          var bufferAmount = channel.getStats();
          self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.BUFFERED_AMOUNT_LOW,
            peerId, error, channelName, channelType, null, bufferAmount);
        });
      
        channel.on(&#x27;data&#x27;, function (data) {
          self._processDataChannelData(data, peerId, channelName, channelType);
        });
      
        channel.init();
      
        if (channelType === self.DATA_CHANNEL_TYPE.MESSAGING) {
          self._dataChannels[peerId].main = {
            channelName: channelName,
            channelType: channelType,
            transferId: null,
            streamId: null,
            channel: channel
          };
        } else {
          self._dataChannels[peerId][channelName] = {
            channelName: channelName,
            channelType: channelType,
            transferId: null,
            streamId: null,
            channel: channel
          };
        }
      };
      
      /**
       * Function that returns the Datachannel buffer threshold and amount.
       * @method _getDataChannelBuffer
       * @return {JSON} The buffered amount information.
       * @private
       * @for Skylink
       * @since 0.6.18
       */
      Skylink.prototype._getDataChannelBuffer = function (peerId, channelProp) {
        if (typeof peerId === &#x27;object&#x27;) {
          return peerId.getStats();
        } else if (!(this._dataChannels[peerId] &amp;&amp; this._dataChannels[peerId][channelProp] &amp;&amp;
          this._dataChannels[peerId][channelProp].channel)) {
          return {
            bufferedAmountLow: 0,
            bufferedAmountLowThreshold: 0
          };
        }
      
        return this._dataChannels[peerId][channelProp].channel.getStats();
      };
      
      /**
       * Function that sends data over the Datachannel connection.
       * @method _sendMessageToDataChannel
       * @private
       * @for Skylink
       * @since 0.5.2
       */
      Skylink.prototype._sendMessageToDataChannel = function(peerId, data, channelProp, doNotConvert, useBufferControl) {
        var self = this;
      
        // Set it as &quot;main&quot; (MESSAGING) Datachannel
        if (!channelProp || channelProp === peerId) {
          channelProp = &#x27;main&#x27;;
        }
      
        // TODO: What happens when we want to send binary data over or ArrayBuffers?
        if (!(typeof data === &#x27;object&#x27; &amp;&amp; data) &amp;&amp; !(data &amp;&amp; typeof data === &#x27;string&#x27;)) {
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping invalid data -&gt;&#x27;], data);
          return;
        }
      
        if (!(self._peerConnections[peerId] &amp;&amp;
          self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED)) {
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
            &#x27;Dropping for sending message as Peer connection does not exists or is closed -&gt;&#x27;], data);
          return;
        }
      
        if (!(self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId][channelProp])) {
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
            &#x27;Dropping for sending message as Datachannel connection does not exists -&gt;&#x27;], data);
          return;
        }
      
        var channelName = self._dataChannels[peerId][channelProp].channelName;
        var channelType = self._dataChannels[peerId][channelProp].channelType;
        var readyState  = self._dataChannels[peerId][channelProp].channel.getStats().readyState;
        var messageType = typeof data === &#x27;object&#x27; &amp;&amp; data.type === self._DC_PROTOCOL_TYPE.MESSAGE ?
          self.DATA_CHANNEL_MESSAGE_ERROR.MESSAGE : self.DATA_CHANNEL_MESSAGE_ERROR.TRANSFER;
      
        if (readyState !== self.DATA_CHANNEL_STATE.OPEN) {
          var notOpenError = &#x27;Failed sending message as Datachannel connection state is not opened. Current &#x27; +
            &#x27;readyState is &quot;&#x27; + readyState + &#x27;&quot;&#x27;;
      
          log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, notOpenError + &#x27; -&gt;&#x27;], data);
      
          self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.SEND_MESSAGE_ERROR, peerId, new Error(notOpenError),
            channelName, channelType, messageType, self._getDataChannelBuffer(peerId, channelProp));
      
          throw new Error(notOpenError);
        }
      
        try {
          if (!doNotConvert &amp;&amp; typeof data === &#x27;object&#x27;) {
            log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Sending &quot;&#x27; + data.type + &#x27;&quot; protocol message -&gt;&#x27;], data);
      
            self._dataChannels[peerId][channelProp].channel.send(JSON.stringify(data), useBufferControl);
      
          } else {
            log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Sending data with size -&gt;&#x27;],
              data.size || data.length || data.byteLength);
      
            self._dataChannels[peerId][channelProp].channel.send(data, useBufferControl);
          }
        } catch (error) {
          log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Failed sending &#x27; + (!doNotConvert &amp;&amp; typeof data === &#x27;object&#x27; ?
            &#x27;&quot;&#x27; + data.type + &#x27;&quot; protocol message&#x27; : &#x27;data&#x27;) + &#x27; -&gt;&#x27;], error);
      
          self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.SEND_MESSAGE_ERROR, peerId,
            error, channelName, channelType, messageType, self._getDataChannelBuffer(peerId, channelProp));
      
          throw error;
        }
      };
      
      /**
       * Function that stops the Datachannel connection and removes object references.
       * @method _closeDataChannel
       * @private
       * @for Skylink
       * @since 0.1.0
       */
      Skylink.prototype._closeDataChannel = function(peerId, channelProp) {
        var self = this;
      
        if (!self._dataChannels[peerId]) {
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp || null,
            &#x27;Aborting closing Datachannels as Peer connection does not have Datachannel sessions&#x27;]);
          return;
        }
      
        var closeFn = function (rChannelProp) {
          var channelName = self._dataChannels[peerId][rChannelProp].channelName;
          var channelType = self._dataChannels[peerId][rChannelProp].channelType;
      
          if (self._dataChannels[peerId][rChannelProp].channel.getStats().readyState !== self.DATA_CHANNEL_STATE.CLOSED) {
            log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Closing Datachannel&#x27;]);
      
            self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.CLOSING, peerId, null, channelName, channelType,
              null, self._getDataChannelBuffer(peerId, rChannelProp));
      
            self._dataChannels[peerId][rChannelProp].channel.close();
      
            delete self._dataChannels[peerId][rChannelProp];
          }
        };
      
        if (!channelProp) {
          for (var channelNameProp in self._dataChannels) {
            if (self._dataChannels[peerId].hasOwnProperty(channelNameProp)) {
              if (self._dataChannels[peerId][channelNameProp]) {
                closeFn(channelNameProp);
              }
            }
          }
        } else {
          if (!self._dataChannels[peerId][channelProp]) {
            log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Aborting closing Datachannel as it does not exists&#x27;]);
            return;
          }
      
          closeFn(channelProp);
        }
      };
          </pre>
      </div>
    </div>
   </section>
</body>
</html>

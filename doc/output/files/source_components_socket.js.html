<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Temasys Web SDK Documentation (0.6.19)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="name" content="skylinkjs">
  <meta name="version" content="0.6.19">
  <!-- Favicon -->
  <link href="../assets/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
  <link href="../assets/vendor/font-awesome.min.css" rel="stylesheet" type="text/css">
  <!-- Styles -->
  <link href="../assets/vendor/prettify.min.css" rel="stylesheet" type="text/css">
  <link href="../assets/css/main.css" rel="stylesheet" type="text/css">
  <script src="../assets/vendor/jquery.min.js" type="text/javascript"></script>
  <script src="../assets/vendor/prettify.min.js" type="text/javascript"></script>
  <script src="../assets/js/main.js" type="text/javascript"></script>
</head>
<body>
  <!-- Navigation Header -->
  <navbar class="top">
    <a class="main" href="/">
      <img src="../assets/img/favicon.ico">
      <strong>Temasys</strong> Web SDK
    </a>
    <ul class="menu">
      <li><a href="https://github.com/Temasys/SkylinkJS" target="_blank">SkylinkJS Github</a></li>
      <li><a href="https://console.temasys.io/" target="_blank">Developer Console</a></li>
    </ul>
  </navbar>

  <!-- Body -->
  <section class="container">
    <div class="container-wrapper">
      <!-- Side Navigation -->
      <navbar class="side">
        <div id="side-menu" class="navbar-wrapper">
          <ul class="menu">
            <div class="section">
              <span class="header">Getting Started</span>    
              <li>
              <a href="#">1. Overview <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Architecture</a></li>
                  <li><a href="#">b. Authentication Methods</a></li>
                  <li><a href="#">c. Persistent Rooms</a></li>
                  <li><a href="#">d. Auto-Introduce & Privileged</a></li>
              </ul>
              </li>
              <li>
              <a href="#">2. Integrating to Your Site <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Referencing the SDK</a></li>
                  <li><a href="#">b. Code Samples</a></li>
                  <li><a href="#">c. Integrating your extensions & WebRTC plugin</a></li>
              </ul>
              </li>
              <li><a href="#" class="nodropdown">3. Demos</a></li>
            </div>
            <div class="section">
              <span class="header">API Documentation</span>
              <li>
                <a href="#">Temasys <small>module</small><i class="fa fa-caret-down"></i></a>
                <ul>
                </ul>
              </li>
                  ([&quot;Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Room.html" class="nodropdown">
                      Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Skylink&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Skylink.html" class="nodropdown">
                      Skylink <small>class</small>
                    </a>
                  </li>
                  ([&quot;Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Socket.html" class="nodropdown">
                      Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Peer&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Peer.html" class="nodropdown">
                      Temasys.Peer <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Room.html" class="nodropdown">
                      Temasys.Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Socket.html" class="nodropdown">
                      Temasys.Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Utils.html" class="nodropdown">
                      Temasys.Utils <small>class</small>
                    </a>
                  </li>
            </div>
          </ul>
        </div>
      </navbar>      <!-- Content -->
      <h1 class="file-heading">File: source/components/socket.js</h1>
      
      <div class="file">
          <pre class="code prettyprint linenums">
      /**
       * Handles the socket connection to the Signaling server.
       * This class is only to be initialised from {{#crossLink &quot;Room&quot;}}{{/crossLink}} class.
       * @class Temasys.Socket
       * @param {JSON} [options] The options.
       * @param {String} [options.server] The Signaling server domain to connect to.
       *   The default is based on the server domain provided by the Auth (API) server.
       * @param {Array} [options.ports] The list of Signaling server ports to connect to.
       *   Priority of port to use are based on first index order starting from &#x60;0&#x60;.
       *   The default is based on the list of ports provided by the Auth (API) server.
       * @param {Number} options.ports.#index The port number to use.
       * @param {String} [options.path] The Signaling server path to connect to.
       *   The default is &#x60;/socket.io&#x60;.
       * @param {String} [options.protocol] The Signaling server protocol to connect to.
       *   The default is the value of the current accessing &#x60;window.location.protocol&#x60;.
       * @param {Array} [options.transports] The list of socket transports to use.
       *   Priority of transport to use are based on first index order starting from &#x60;0&#x60;.
       *   The default is &#x60;(&quot;websocket&quot;, &quot;polling&quot;)&#x60;, or &#x60;(&quot;polling&quot;)&#x60; only if Websocket transport is not supported.
       * @param {String} options.transports.#index The transport item to use.
       *   Available options are: &#x60;&quot;websocket&quot;&#x60; (Websocket) and &#x60;&quot;polling&quot;&#x60; (Polling).
       * @param {Boolean} [options.compressData] The flag if data sent to Signaling server should be compressed.
       *   The default is &#x60;false&#x60;.
       * @param {JSON} options.options The socket options for each transport type.
       * @param {JSON} options.options.#transport The socket options for transport type.
       *   The &#x60;#transport&#x60; key is either &#x60;&quot;websocket&quot;&#x60; (Websocket) or &#x60;&quot;polling&quot;&#x60; (Polling).
       * @param {Boolean} [options.options.#transport.reconnection] The flag if socket should attempt
       *   reconnection for each port and transport type.
       *   The default is &#x60;true&#x60;.
       * @param {Number} [options.options.#transport.reconnection] The flag if socket should attempt at least several
       *   reconnections for current port and transport type before switching to the next available port or transport.
       *   The defaults are &#x60;true&#x60; for both Websocket and Polling.
       * @param {Number} [options.options.#transport.reconnectionAttempts] The reconnection attempts to
       *   take if reconnection is enabled for each port and transport type.
       *   The defaults are &#x60;2&#x60; for Websocket and &#x60;4&#x60; for Polling. The maximum is &#x60;5&#x60;.
       * @param {Number} [options.options.#transport.reconnectionDelay] The number of miliseconds to initially
       *   wait before attempting a new reconnection. This is affected by the randomization factor range.
       *   The defaults are &#x60;5000&#x60; for Websocket and &#x60;2000&#x60; for Polling.
       * @param {Number} [options.options.#transport.reconnectionDelayMax] The maximum number of miliseconds to
       *   wait between reconnections. This increases the reconnection delay for randomization factor range
       *   before waiting to start a reconnection.
       *   The defaults are &#x60;2000&#x60; for Websocket and &#x60;1000&#x60; for Polling.
       * @param {Number} [options.options.#transport.randomizationFactor] The randomization
       *   factor range from &#x60;0&#x60; to &#x60;1&#x60;.
       *   The defaults are &#x60;0.5&#x60; for both Websocket and Polling.
       * @param {Number} [options.options.#transport.timeout] The timeout in miliseconds to consider
       *   that the connection timed out.
       *   The defaults are &#x60;20000&#x60; for both Websocket and Polling.
       * @constructor
       * @since 0.7.0
       */
      function Socket (options, defaultOptions) {
        options = options &amp;&amp; typeof options === &#x27;object&#x27; ? options : {};
      
        /**
         * The Signaling server domain.
         * @attribute server
         * @type String
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.server = options.server &amp;&amp; typeof options.server === &#x27;string&#x27; ? options.server :
          (defaultOptions.server &amp;&amp; typeof defaultOptions.server === &#x27;string&#x27; ?
          defaultOptions.server : &#x27;signaling.temasys.io&#x27;);
      
        /**
         * The Signaling server path.
         * @attribute path
         * @type String
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.path = options.path &amp;&amp; typeof options.path === &#x27;string&#x27; ? options.path : &#x27;/socket.io&#x27;;
      
        /**
         * The Signaling server protocol.
         * @attribute protocol
         * @type String
         * @readOnly
         * @for Socket
         * @since 0.7.0
         */
        this.protocol = options.protocol &amp;&amp; typeof options.protocol === &#x27;string&#x27; &amp;&amp; options.protocol.length &gt; 2 &amp;&amp;
          options.protocol.indexOf(&#x27;:&#x27;) === (options.protocol.length - 1) ? options.protocol : window.location.protocol;
      
        /**
         * The flag if messages sent to the Signaling server are compressed.
         * @attribute compressed
         * @type Boolean
         * @readOnly
         * @for Socket
         * @since 0.7.0
         */
        this.compressed = options.compressData === true;
      
        /**
         * The current socket connection status.
         * @attribute current
         * @type JSON
         * @param {String} state The current socket connection state.
         *   References the &#x60;STATES&#x60; enum attribute.
         * @param {Boolean} connected The flag if socket connection is connected.
         * @param {Number} reconnectionAttempts The current number of reconnection attempts
         *   made for the current port and transport used.
         * @param {Number} fallbackAttempts The current number of fallback attempts
         *   made for each available ports and transports.
         * @param {Number} port The current port to connect used.
         * @param {String} transport The current socket transport used.
         * @param {JSON} options The current socket.io-client options used.
         * @readOnly
         * @for Socket
         * @since 0.7.0
         */
        this.current = {
          state: null,
          connected: false,
          reconnectionAttempts: 0,
          fallbackAttempts: 0,
          port: null,
          transport: null,
          options: null
        };
      
        // Private variables
        // Event manager
        this._event = Utils.createEventManager();
        // Socket.io-client connection
        this._connection = null;
        // The cached config
        this._config = {
          // Configure user defined ports
          ports: Array.isArray(options.ports) &amp;&amp; options.ports.length &gt; 0 ? {
            &#x27;https:&#x27;: options.ports,
            &#x27;http:&#x27;: options.ports
          // Configure API given ports, if not fallback
          } : {
            &#x27;https:&#x27;: Array.isArray(defaultOptions.httpsPorts) &amp;&amp; defaultOptions.httpsPorts.length &gt; 0 ?
              defaultOptions.httpsPorts : [443, 3443],
            &#x27;http:&#x27;: Array.isArray(defaultOptions.httpPorts) &amp;&amp; defaultOptions.httpPorts.length &gt; 0 ?
              defaultOptions.httpPorts : [80, 3000]
          },
          // Configure user defined transports, if not fallback
          transports: Array.isArray(options.transports) &amp;&amp; options.transports.length &gt; 0 ?
            options.transports : (window.WebSocket ? [&#x27;websocket&#x27;, &#x27;polling&#x27;] : [&#x27;polling&#x27;]),
          options: options.options &amp;&amp; typeof options.options === &#x27;object&#x27; ? options.options : {}
        };
        // The socket messages grouping and queue. Follows SM 0.1.2 protocol except for &quot;roomLockEvent&quot; being queued.
        this._buffer = {
          // 0: Stringified messages, 1: Callbacks
          queue: [[], []],
          timer: false,
          timestamp: 0,
          status: {
            updateUserEvent: 0,
            muteAudioEvent: 0,
            muteVideoEvent: 0
          },
          cached: {
            room: null,
            user: null
          }
        };
      
        // Events
        /**
         * Event triggered when socket connection state has changed.
         * @event state
         * @param {String} state The current socket connection state.
         *   References the {{#crossLink &quot;Socket/STATE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @param {Error} error The error object.
         *   This is defined when &#x60;state&#x60; value is &#x60;STATE_ENUM.RECONNECT_FAILED&#x60;,
         *   &#x60;STATE_ENUM.CONNECT_ERROR&#x60; and &#x60;STATE_ENUM.CONNECT_TIMEOUT&#x60;.
         * @param {JSON} current The current socket connection status.
         * @param {Number} current.reconnectionAttempts The current reconnection attempts for the current port and transport used.
         * @param {Number} current.port The current port used.
         * @param {String} current.transport The current transport used.
         * @for Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when socket connection sends or receives a message.
         * @event message
         * @param {JSON} message The socket message received or sent.
         * @param {Error} [error] The error object.
         *   This is defined when message failed to send or parse when received.
         * @param {Boolean} isSelf The flag if message is sent from self or not.
         * @for Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when there are exceptions thrown in this event handlers.
         * @event domError
         * @param {Error} error The error object.
         * @for Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when socket connection receives and sends responses to Signaling server for keep-alive.
         * @event response
         * @param {String} state The current socket connection response state.
         *   References the {{#crossLink &quot;Socket/RESPONSE_ENUM:attribute&quot;}}{{/crossLink}} enum attribute.
         * @param {Number} timestamp The current timestamp in miliseconds.
         * @param {Number} [latency] The current latency in miliseconds from receiving
         *   the &#x60;RESPONSE.PONG&#x60; after sending out a &#x60;RESPONSE_ENUM.PING&#x60;.
         * @for Socket
         * @since 0.7.0
         */
        (function (ref) {
          /**
           * Function to subscribe to an event.
           * @method on
           * @param {String} event The event to subscribe to once.
           * @param {Function} callback The callback listener function.
           * @for Socket
           * @since 0.7.0
           */
          ref.on = ref._event.on;
      
          /**
           * Function to subscribe to an event once.
           * @method once
           * @param {String} event The event to subscribe to once.
           * @param {Function} callback The callback listener function.
           * @param {Function} [condition] The condition function that is called when
           *   event is triggered. If condition is met (when function returns &#x60;true&#x60;), the
           *   callback listener function is triggered.
           *   The default is &#x60;function () { return true; }&#x60;.
           * @param {Boolean} [fireAlways] The flag if callback listener function should always
           *   be triggered regardless as long as condition function is met.
           *   The default is &#x60;false&#x60;.
           * @for Socket
           * @since 0.7.0
           */
          ref.once = ref._event.once;
      
          /**
           * Function to unsubscribe to events.
           * @method off
           * @param {String} [event] The specified event to unsubscribe.
           *   When not provided, it will unsubscribe all event callback listener functions.
           * @param {Function} [callback] The specified callback listener function based on
           *   the provided event to unsubscribe only.
           *   When not provided, it will unsubscribe all callback listener functions subscribed to the event.
           * @for Socket
           * @since 0.7.0
           */
          ref.off = ref._event.off;
      
          // Catch errors to prevent issues for socket connection
          ref._event.catch(function (error) {
            ref._event.emit(&#x27;domError&#x27;, error);
          });
        })(this);
      }
      
      /**
       * The enum of socket connection states.
       * @attribute STATE_ENUM
       * @param {String} RECONNECT_FAILED The state when socket connection failed to reconnect after
       *   the several specified attempts configured for the current port and transport used.
       *   At this state, the socket connection will fallback to the next available port or transport.
       * @param {String} RECONNECT_ERROR The state when socket connection failed to reconnect for the
       *   current attempt.
       * @param {String} RECONNECT_ATTEMPT The state when socket connection is attempting to reconnect.
       * @param {String} RECONNECTING The state when socket connection is reconnecting.
       * @param {String} RECONNECT The state when socket connection has reconnected successfully.
       * @param {String} CONNECT_TIMEOUT The state when socket connection has failed to connect after
       *   the specified timeout configured for the current port and transport.
       *   At this state, the socket connection will attempt to reconnect a few more times if reconnection is enabled.
       * @param {String} CONNECT_ERROR The state when socket connection has errors and disconnects.
       * @param {String} CONNECT The state when socket connection has connected successfully.
       * @param {String} DISCONNECT The state when socket connection has been disconnected.
       * @param {String} ABORT The state when socket connection has aborted from attempting any available
       *   ports or transports or reconnection as there is none left to reconnect or fallback with.
       * @param {String} CONSTRUCT_ERROR The state when socket connection failed to construct.
       * @type JSON
       * @for Socket
       * @since 0.7.0
       */
      Socket.prototype.STATE_ENUM = {
        RECONNECT_ATTEMPT: &#x27;reconnect_attempt&#x27;,
        RECONNECT_FAILED: &#x27;reconnect_failed&#x27;,
        RECONNECT_ERROR: &#x27;reconnect_error&#x27;,
        RECONNECTING: &#x27;reconnecting&#x27;,
        RECONNECT: &#x27;reconnect&#x27;,
        CONNECT_TIMEOUT: &#x27;connect_timeout&#x27;,
        CONNECT_ERROR: &#x27;connect_error&#x27;,
        CONNECT: &#x27;connect&#x27;,
        DISCONNECT: &#x27;disconnect&#x27;,
        ABORT: &#x27;abort&#x27;,
        CONSTRUCT_ERROR: &#x27;construct_error&#x27;
      };
      
      /**
       * The enum of socket response states.
       * @attribute RESPONSE_ENUM
       * @param {String} PING The state when ping packet is written out to Signaling server.
       * @param {String} PONG The state when pong packet response is received from Signaling server.
       * @type JSON
       * @for Socket
       * @since 0.7.0
       */
      Socket.prototype.RESPONSE_ENUM = {
        PING: &#x27;ping&#x27;,
        PONG: &#x27;pong&#x27;
      };
      
      /**
       * Function to start socket connection.
       */
      Socket.prototype._connect = function (fn) {
        var ref = this;
        // These are stored states since sometimes the event is triggered after the restart
        var eventAttempts = 0, eventPort = null, eventTransport = null, isFnTriggered = false;
        var usePorts = ref._config.ports[ref.protocol];
        var useTransports = ref._config.transports;
      
        /**
         * Internal function to update &quot;state&quot; event.
         */
        var fnUpdate = function (state, error) {
          // Check if state is reconnect_attempt
          if (state === ref.STATE_ENUM.RECONNECT_ATTEMPT) {
            eventAttempts++;
          }
      
          ref.current.state = state;
      
          ref._event.emit(&#x27;state&#x27;, state, error || null, {
            reconnectionAttempts: eventAttempts,
            transport: eventTransport,
            port: eventPort
          });
      
          // Check state to fallback next available port or transport
          if ((state === ref.STATE_ENUM.CONNECT_TIMEOUT &amp;&amp; !ref.current.options.reconnection) ||
            state === ref.STATE_ENUM.RECONNECT_FAILED) {
            ref._disconnect();
            ref._connect(fn);
      
          // Res callback as it is successful
          } else if ([ref.STATE_ENUM.RECONNECT, ref.STATE_ENUM.CONNECT].indexOf(state) &gt; -1 &amp;&amp; !ref.current.connected) {
            ref.current.connected = true;
            if (!isFnTriggered) {
              isFnTriggered = true;
              fn(null);
            }
      
          // Res that disconnect has been made
          } else if (state === ref.STATE_ENUM.DISCONNECT) {
            if (!ref.current.connected) {
              return;
            }
            ref.current.connected = true;
      
          // Res callback has failed
          } else if ([ref.STATE_ENUM.ABORT, ref.STATE_ENUM.CONSTRUCT_ERROR].indexOf(state) &gt; -1 &amp;&amp; !isFnTriggered) {
            isFnTriggered = true;
            fn(new Error(&#x27;Failed to connect&#x27;));
          }
        };
      
        // Initial connection
        if (ref.current.port === null) {
          ref.current.port = usePorts[0];
          ref.current.transport = useTransports[0];
          ref.current.fallbackAttempts = 0;
      
        // Fallback to next available transport
        } else if (ref.current.port === usePorts[usePorts.length - 1]) {
          // Last available transport, aborted
          if (ref.current.transport === useTransports[useTransports.length - 1]) {
            return fnUpdate(ref.STATE_ENUM.ABORT);
          }
      
          ref.current.transport = useTransports[useTransports.indexOf(ref.current.transport) + 1];
          ref.current.port = usePorts[0];
          ref.current.fallbackAttempts++;
      
        // Fallback to next available port
        } else {
          ref.current.port = usePorts[usePorts.indexOf(ref.current.port) + 1];
          ref.current.fallbackAttempts++;
        }
      
        // Configure the socket.io-client options
        var useOptions = ref._config.options[ref.current.transport];
      
        useOptions = useOptions &amp;&amp; typeof useOptions === &#x27;object&#x27; ? useOptions : {};
        eventPort = ref.current.port;
        eventTransport = ref.current.transport;
      
        ref.current.attempts = 0;
        ref.current.options = {
          // Configure socket.io-client /path
          path: ref.path,
          // Configure socket.io-client reconnection option
          reconnection: useOptions.reconnection !== false,
          // Configure socket.io-client reconnection attempts. Must be less or equals to 5
          reconnectionAttempts: typeof useOptions.reconnectionAttempts === &#x27;number&#x27; &amp;&amp;
            useOptions.reconnectionAttempts &lt;= 5 ? useOptions.reconnectionAttempts :
            (ref.current.transport === &#x27;websocket&#x27; ? 2 : 4),
          // Configure socket.io-client reconnection delay
          reconnectionDelay: typeof useOptions.reconnectionDelay === &#x27;number&#x27; ? useOptions.reconnectionDelay :
            (ref.current.transport === &#x27;websocket&#x27; ? 5000 : 2000),
          // Configure socket.io-client reconnection delay max
          reconnectionDelayMax: typeof useOptions.reconnectionDelayMax === &#x27;number&#x27; ? useOptions.reconnectionDelayMax :
            (ref.current.transport === &#x27;websocket&#x27; ? 2000 : 1000),
          // Configure socket.io-client randomization factor
          randomizationFactor: typeof useOptions.randomizationFactor === &#x27;number&#x27; &amp;&amp;
            useOptions.randomizationFactor &gt;= 0 &amp;&amp; useOptions.randomizationFactor &lt;= 1 ?
            useOptions.randomizationFactor : 0.5,
          // Configure socket.io-client timeout first to consider failure
          timeout: typeof useOptions.timeout === &#x27;number&#x27; ? useOptions.timeout : 20000,
          // Configure socket.io-client transports
          transports: [ref.current.transport],
          // Let us call &#x60;.open()&#x60; manually later
          autoConnect: false,
          // Deprecated socket.io-client 1.4.x
          forceNew: true
        };
      
        var socket = null;
      
        // Catch any &quot;http:&quot; accessing errors on &quot;https:&quot; sites errors
        // Deprecated socket.io-client 1.4.x
        try {
          socket = io.connect(ref.protocol + &#x27;//&#x27; + ref.server + &#x27;:&#x27; + ref.current.port, ref.current.options);
        } catch (error) {
          return fnUpdate(ref.STATE_ENUM.CONSTRUCT_ERROR, error);
        }
      
        /**
         * Socket.io-client &quot;connect&quot; state.
         */
        socket.on(&#x27;connect&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.CONNECT);
        });
      
        /**
         * Socket.io-client &quot;reconnect&quot; state.
         */
        socket.on(&#x27;reconnect&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECT);
        });
      
        /**
         * Socket.io-client &quot;disconnect&quot; state.
         */
        socket.on(&#x27;disconnect&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.DISCONNECT);
        });
      
        /**
         * Socket.io-client &quot;connect_timeout&quot; state.
         */
        socket.on(&#x27;connect_timeout&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.CONNECT_TIMEOUT);
        });
      
        /**
         * Socket.io-client &quot;connect_error&quot; state.
         */
        socket.on(&#x27;connect_error&#x27;, function (error) {
          fnUpdate(ref.STATE_ENUM.CONNECT_ERROR, error &amp;&amp; typeof error === &#x27;object&#x27; ?
            error : new Error(error || &#x27;Connect error&#x27;));
        });
      
        /**
         * Socket.io-client &quot;reconnecting&quot; state.
         */
        socket.on(&#x27;reconnecting&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECTING);
        });
      
        /**
         * Socket.io-client &quot;reconnect_error&quot; state.
         */
        socket.on(&#x27;reconnect_error&#x27;, function (error) {
          fnUpdate(ref.STATE_ENUM.RECONNECT_ERROR, error &amp;&amp; typeof error === &#x27;object&#x27; ?
            error : new Error(error || &#x27;Reconnect error&#x27;));
        });
      
        /**
         * Socket.io-client &quot;reconnect_failed&quot; state.
         */
        socket.on(&#x27;reconnect_failed&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECT_FAILED);
        });
      
        /**
         * Socket.io-client &quot;reconnect_failed&quot; state.
         */
        socket.on(&#x27;reconnect_attempt&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECT_ATTEMPT);
        });
      
        /**
         * Socket.io-client &quot;error&quot; state.
         * Deprecated socket.io-client 1.4.x
         */
        socket.on(&#x27;error&#x27;, function (error) {
          ref._event.emit(&#x27;domError&#x27;, error &amp;&amp; typeof error === &#x27;object&#x27; ?
            error : new Error(error || &#x27;DOM exception&#x27;));
        });
      
        /**
         * Socket.io-client &quot;ping&quot; state.
         */
        socket.on(&#x27;ping&#x27;, function () {
          ref._event.emit(&#x27;response&#x27;, ref.RESPONSE_ENUM.PING, Date.now(), null);
        });
      
        /**
         * Socket.io-client &quot;pong&quot; state.
         */
        socket.on(&#x27;pong&#x27;, function (latency) {
          ref._event.emit(&#x27;response&#x27;, ref.RESPONSE_ENUM.PONG, Date.now(), latency);
        });
      
        /**
         * Socket.io-client &quot;message&quot; state.
         */
        socket.on(&#x27;message&#x27;, function (messageStr) {
          var message = JSON.parse(messageStr);
          // Cache the room ID for group messages later
          if (message.type === &#x27;inRoom&#x27;) {
            ref._buffer.cached.room = message.rid;
            ref._buffer.cached.user = message.sid;
          }
          ref._event.emit(&#x27;message&#x27;, message, null, false);
        });
      
        ref._connection = socket;
      
        if (typeof socket.connect === &#x27;function&#x27;) {
          // Catch any &quot;http:&quot; accessing errors on &quot;https:&quot; sites errors
          try {
            socket.connect();
          } catch (error) {
            fnUpdate(ref.STATE_ENUM.CONSTRUCT_ERROR, error);
          }
        }
      };
      
      /**
       * Function to stop socket connection.
       */
      Socket.prototype._disconnect = function () {
        var ref = this;
      
        if (ref._connection) {
          if (ref.current.connected) {
            ref._connection.disconnect();
          }
          ref._connection = null;
        }
      };
      
      /**
       * Function to send the next batch of queued messages.
       */
      Socket.prototype._sendNextQueue = function (fnSend) {
        var ref = this;
      
        if (ref._buffer.timer) {
          clearTimeout(ref._buffer.timer);
        }
      
        ref._buffer.timer = setTimeout(function () {
          // Ignore if there is no queue to send
          if (ref._buffer.queue[0].length === 0) {
            return;
          }
      
          var now = Date.now();
      
          if ((now - ref._buffer.timestamp) &gt; 1000) {
            Utils.forEach(ref._buffer.queue[0], function (qMessageStr, i) {
              var qMessage = JSON.parse(qMessageStr);
              // Drop outdated messages
              if ([&#x27;muteVideoEvent&#x27;, &#x27;muteAudioEvent&#x27;, &#x27;updateUserEvent&#x27;].indexOf(qMessage.type) &gt; -1 &amp;&amp;
                ref._buffer.status[qMessage.type] &gt;= qMessage.stamp) {
                ref._buffer.queue[0].splice(i, 1);
                // Trigger callback because status is outdated so it&#x27;s technically updated
                ref._buffer.queue[1].splice(i, 1)[0](null);
                return -1;
              }
            });
      
            var messageList = ref._buffer.queue[0].splice(0, 16);
            var fnList = ref._buffer.queue[1].splice(0, 16);
      
            // Send the next batch
            fnSend([{
              type: &#x27;group&#x27;,
              mid: ref._buffer.cached.user,
              rid: ref._buffer.cached.room,
              list: messageList
      
            }, function (error) {
              Utils.forEach(fnList, function (fnItem, i) {
                ref._event.emit(&#x27;message&#x27;, JSON.parse(messageList[i]), error || null, true);
                fnItem(error || null);
              });
            }]);
            ref._buffer.timestamp = now;
            ref._sendNextQueue(fnSend);
          }
        }, 1000);
      };
      
      /**
       * Function to send messages.
       */
      Socket.prototype._send = function (message, fn) {
        var ref = this;
      
        /**
         * Internal function to send message.
         */
        var fnSend = function (item) {
          if (!(ref._connection &amp;&amp; ref.current.connected)) {
            var notOpenError = new Error(&#x27;Failed to send message as socket is not connected&#x27;);
            ref._event.emit(&#x27;message&#x27;, item[0], notOpenError, true);
            return item[1](notOpenError);
          }
      
          // &quot;compress&quot; functionality may not work until server has implemented it
          ref._connection.compress(ref.compressData).send(item[0], function () {
            // TODO: Server to send ack? Not documenting this as it might not be available yet
            ref._event.emit(&#x27;messageAck&#x27;, item[0]);
          });
      
          ref._event.emit(&#x27;message&#x27;, item[0], null, true);
          item[1](null);
        };
      
        // Priority channel which should not be buffered in which server should queue that.
        if ([&#x27;joinRoom&#x27;, &#x27;enter&#x27;, &#x27;restart&#x27;, &#x27;welcome&#x27;, &#x27;endOfCandidates&#x27;].indexOf(message.type) &gt; -1) {
          fnSend([message, typeof fn === &#x27;function&#x27; ? fn : function () {}]);
      
        // Messaging channel for broadcast or info messages to buffer which server would drop
        } else if ([&#x27;private&#x27;, &#x27;roomLockEvent&#x27;, &#x27;stream&#x27;, &#x27;public&#x27;, &#x27;updateUserEvent&#x27;,
          &#x27;muteAudioEvent&#x27;, &#x27;muteVideoEvent&#x27;].indexOf(message.type) &gt; -1) {
      
          setTimeout(function () {
            var now = Date.now();
      
            // Set the stamp value
            if ([&#x27;muteVideoEvent&#x27;, &#x27;muteAudioEvent&#x27;, &#x27;updateUserEvent&#x27;].indexOf(message.type) &gt; -1) {
              ref._buffer.status[message.type] = now;
              message.stamp = now;
            }
      
            if ((now - ref._buffer.timestamp) &gt; (message.type === &#x27;private&#x27; ? 120 : 1000)) {
              fnSend([message, typeof fn === &#x27;function&#x27; ? fn : function () {}]);
              ref._buffer.timestamp = now;
              ref._sendNextQueue(fnSend);
              return;
            }
      
            // Prevent delayed Room locks
            if (message.type === &#x27;roomLockEvent&#x27;) {
              var droppedError = new Error(&#x27;Unable to send command to lock Room due to messages buffer&#x27;);
              ref._emit(&#x27;message&#x27;, message, droppedError, true);
              (typeof fn === &#x27;function&#x27; ? fn : function () {})(droppedError);
              return;
            }
      
            ref._buffer.queue[0].push(JSON.stringify(message));
            ref._buffer.queue[1].push(typeof fn === &#x27;function&#x27; ? fn : function () {});
            ref._sendNextQueue(fnSend);
          }, 0);
      
        // Invalid messages which is not part of the SM protocol
        } else {
          var invalidError = new Error(&#x27;Invalid message type provided&#x27;);
          ref._event.emit(&#x27;message&#x27;, message, invalidError, true);
          if (typeof fn === &#x27;function&#x27;) {
            fn(invalidError);
          }
        }
      };
          </pre>
      </div>
    </div>
   </section>
</body>
</html>

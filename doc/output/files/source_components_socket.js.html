<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Temasys Web SDK Documentation (0.6.19)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="name" content="skylinkjs">
  <meta name="version" content="0.6.19">
  <!-- Favicon -->
  <link href="../assets/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
  <link href="../assets/vendor/font-awesome.min.css" rel="stylesheet" type="text/css">
  <!-- Styles -->
  <link href="../assets/vendor/prettify.min.css" rel="stylesheet" type="text/css">
  <link href="../assets/css/main.css" rel="stylesheet" type="text/css">
  <script src="../assets/vendor/jquery.min.js" type="text/javascript"></script>
  <script src="../assets/vendor/prettify.min.js" type="text/javascript"></script>
  <script src="../assets/js/main.js" type="text/javascript"></script>
</head>
<body>
  <!-- Navigation Header -->
  <navbar class="top">
    <a class="main" href="/">
      <img src="../assets/img/favicon.ico">
      <strong>Temasys</strong> Web SDK
    </a>
    <ul class="menu">
      <li><a href="https://github.com/Temasys/SkylinkJS" target="_blank">SkylinkJS Github</a></li>
      <li><a href="https://console.temasys.io/" target="_blank">Developer Console</a></li>
    </ul>
  </navbar>

  <!-- Body -->
  <section class="container">
    <div class="container-wrapper">
      <!-- Side Navigation -->
      <navbar class="side">
        <div id="side-menu" class="navbar-wrapper">
          <ul class="menu">
            <div class="section">
              <span class="header">Getting Started</span>    
              <li>
              <a href="#">1. Overview <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Architecture</a></li>
                  <li><a href="#">b. Authentication Methods</a></li>
                  <li><a href="#">c. Persistent Rooms</a></li>
                  <li><a href="#">d. Auto-Introduce & Privileged</a></li>
              </ul>
              </li>
              <li>
              <a href="#">2. Integrating to Your Site <i class="fa fa-caret-down"></i></a>
              <ul>
                  <li><a href="#">a. Referencing the SDK</a></li>
                  <li><a href="#">b. Code Samples</a></li>
                  <li><a href="#">c. Integrating your extensions & WebRTC plugin</a></li>
              </ul>
              </li>
              <li><a href="#" class="nodropdown">3. Demos</a></li>
            </div>
            <div class="section">
              <span class="header">API Documentation</span>
              <li>
                <a href="#">Temasys <small>module</small><i class="fa fa-caret-down"></i></a>
                <ul>
                </ul>
              </li>
                  ([&quot;Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Room.html" class="nodropdown">
                      Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Skylink&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Skylink.html" class="nodropdown">
                      Skylink <small>class</small>
                    </a>
                  </li>
                  ([&quot;Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Socket.html" class="nodropdown">
                      Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.html" class="nodropdown">
                      Temasys <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Datachannel&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Datachannel.html" class="nodropdown">
                      Temasys.Datachannel <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Peer&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Peer.html" class="nodropdown">
                      Temasys.Peer <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Room&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Room.html" class="nodropdown">
                      Temasys.Room <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Socket&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Socket.html" class="nodropdown">
                      Temasys.Socket <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Stream&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Stream.html" class="nodropdown">
                      Temasys.Stream <small>class</small>
                    </a>
                  </li>
                  ([&quot;Temasys.Utils&quot;,&quot;test&quot;])
                  <li>
                    <a href="classes/Temasys.Utils.html" class="nodropdown">
                      Temasys.Utils <small>class</small>
                    </a>
                  </li>
            </div>
          </ul>
        </div>
      </navbar>      <!-- Content -->
      <h1 class="file-heading">File: source/components/socket.js</h1>
      
      <div class="file">
          <pre class="code prettyprint linenums">
      /**
       * Handles the Room socket.io-client connection to the Signling server.
       * @class Temasys.Socket
       * @param {JSON} [options] The options.
       * @param {String} [options.server] @[exp] The custom Signaling server domain to use.
       * @param {Array} [options.ports] @[exp] The custom list of Signaling server ports (&#x60;Number&#x60;) to use.
       * - The priority of port used is based on first index order starting from &#x60;0&#x60;.
       * @param {String} [options.path] @[exp] The custom Signaling server path to use.
       * @param {String} [options.protocol] The protocol to use to connect to the Signaling server.
       * - When not provided, the current accessing &#x60;window.location.protocol&#x60; will be used.
       * @param {Array} [options.transports] The list of socket.io-client transports to use.
       * - Available transports are: &#x60;&quot;websocket&quot;&#x60; (Websocket) and &#x60;&quot;polling&quot;&#x60; (Polling).
       * - The priority of transport to use are based on first index order starting from &#x60;0&#x60;.
       * - When not provided, &#x60;(&quot;websocket&quot;, &quot;polling&quot;)&#x60; will be used.
       * - If the browser does not support &#x60;WebSocket&#x60; API, &#x60;&quot;websocket&quot;&#x60; transports will be ignored.
       * @param {Boolean} [options.compressData=false] The flag if data sent should be compressed.
       * @param {JSON} options.options The socket.io-client options configured for each socket.io-client transport type.
       * - The current default is &#x60;{ websocket: { reconnection: true, reconnectionAttempts: 2,
       *   reconnectionDelay: 5000, reconnectionDelayMax: 2000, randomizationFactor: 0.5, timeout: 20000 },
       *   polling: { reconnection: true, reconnectionAttempts: 4, reconnectionDelay: 2000,
       *   reconnectionDelayMax: 1000, randomizationFactor: 0.5, timeout: 20000 } }&#x60;
       * @param {JSON} options.options.index @[exp] The socket options for the &#x60;&quot;index&quot;&#x60; socket.io-client transport type.
       * - &#x60;&quot;index&quot;&#x60; can be identified as: &#x60;&quot;websocket&quot;&#x60; (Websocket) or &#x60;&quot;polling&quot;&#x60; (Polling).
       * @param {Boolean} [options.options.index.reconnection=true] The flag if socket connection should
       *   reconnect several attempts for the current transport or port used before switching to the next
       *   available transport or port available.
       * @param {Number} [options.options.index.reconnectionAttempts] The reconnection attempts to take if
       *   &#x60;options.options.index.reconnection&#x60; is enabled.
       * - The maximum value that can be provided is &#x60;5&#x60;.
       * @param {Number} [options.options.index.reconnectionDelay] The number of miliseconds to wait before
       *   starting the next reconnection attempt, which is affected by the &#x60;randomizationFactor&#x60; configured.
       * @param {Number} [options.options.index.reconnectionDelayMax] The maximum number of miliseconds to wait
       *   before starting the next reconnection attempt.
       * @param {Number} [options.options.index.randomizationFactor] The randomization for each reconnection attempt.
       * - The range is from &#x60;0&#x60; to &#x60;1&#x60;.
       * @param {Number} [options.options.index.timeout] The timeout in miliseconds to consider
       *   that the inital connection has timed out.
       * @constructor
       * @private
       * @for Temasys
       * @since 0.7.0
       */
      function Socket (options, defaultOptions) {
        options = options &amp;&amp; typeof options === &#x27;object&#x27; ? options : {};
      
        /**
         * The Socket server domain.
         * @attribute server
         * @type String
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.server = options.server &amp;&amp; typeof options.server === &#x27;string&#x27; ? options.server :
          (defaultOptions.server &amp;&amp; typeof defaultOptions.server === &#x27;string&#x27; ?
          defaultOptions.server : &#x27;signaling.temasys.io&#x27;);
      
        /**
         * The Socket path.
         * @attribute path
         * @type String
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.path = options.path &amp;&amp; typeof options.path === &#x27;string&#x27; ? options.path : &#x27;/socket.io&#x27;;
      
        /**
         * The Socket protocol.
         * @attribute protocol
         * @type String
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.protocol = options.protocol &amp;&amp; typeof options.protocol === &#x27;string&#x27; &amp;&amp; options.protocol.length &gt; 2 &amp;&amp;
          options.protocol.indexOf(&#x27;:&#x27;) === (options.protocol.length - 1) ? options.protocol : window.location.protocol;
      
        /**
         * The flag if Socket data sent is compressed.
         * @attribute compressed
         * @type Boolean
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.compressed = options.compressData === true;
      
        /**
         * The Socket current states.
         * @attribute $current
         * @type JSON
         * @param {String} state The current Socket connection state.
         * - See {{#crossLink &quot;Temasys.Socket/STATE_ENUM:attribute&quot;}}{{/crossLink}} for reference.
         * @param {Boolean} connected The flag if Socket is connected.
         * @param {Number} reconnectionAttempts The current total number of reconnection attempts
         *   made for the current port and socket.io-client transport used.
         * @param {Number} fallbackAttempts The current total number of fallback attempts made.
         * @param {Number} port The current port used.
         * @param {String} transport The current socket.io-client transport used.
         * @param {JSON} options The current socket.io-client options used.
         * @readOnly
         * @for Temasys.Socket
         * @since 0.7.0
         */
        this.$current = {
          state: null,
          connected: false,
          reconnectionAttempts: 0,
          fallbackAttempts: 0,
          port: null,
          transport: null,
          options: null
        };
      
        // Private variables
        // Event manager
        this._event = Utils.createEventManager();
        // Socket.io-client connection
        this._connection = null;
        // The cached config
        this._config = {
          // Configure user defined ports
          ports: Array.isArray(options.ports) &amp;&amp; options.ports.length &gt; 0 ? {
            &#x27;https:&#x27;: options.ports,
            &#x27;http:&#x27;: options.ports
          // Configure API given ports, if not fallback
          } : {
            &#x27;https:&#x27;: Array.isArray(defaultOptions.httpsPorts) &amp;&amp; defaultOptions.httpsPorts.length &gt; 0 ?
              defaultOptions.httpsPorts : [443, 3443],
            &#x27;http:&#x27;: Array.isArray(defaultOptions.httpPorts) &amp;&amp; defaultOptions.httpPorts.length &gt; 0 ?
              defaultOptions.httpPorts : [80, 3000]
          },
          // Configure user defined transports, if not fallback
          transports: Array.isArray(options.transports) &amp;&amp; options.transports.length &gt; 0 ?
            options.transports : (window.WebSocket ? [&#x27;websocket&#x27;, &#x27;polling&#x27;] : [&#x27;polling&#x27;]),
          options: options.options &amp;&amp; typeof options.options === &#x27;object&#x27; ? options.options : {}
        };
        // The socket messages grouping and queue. Follows SM 0.1.2 protocol except for &quot;roomLockEvent&quot; being queued.
        this._buffer = {
          // 0: Stringified messages, 1: Callbacks
          queue: [[], []],
          timer: false,
          timestamp: 0,
          status: {
            updateUserEvent: 0,
            muteAudioEvent: 0,
            muteVideoEvent: 0
          },
          cached: {
            room: null,
            user: null
          }
        };
      
        // Events
        /**
         * Event triggered when Socket connection state has been changed.
         * @event stateChange
         * @param {String} state The current Socket connection state.
         * - See {{#crossLink &quot;Temasys.Socket/STATE_ENUM:attribute&quot;}}{{/crossLink}} for reference.
         * @param {Error} error The error object.
         * - This is defined when &#x60;state&#x60; is &#x60;STATE_ENUM.RECONNECT_FAILED&#x60;,
         *   &#x60;STATE_ENUM.CONNECT_ERROR&#x60; and &#x60;STATE_ENUM.CONNECT_TIMEOUT&#x60;.
         * @param {Number} attempt The reconnection attempt.
         * @param {Number} port The port used for the reconnection attempt.
         * @param {Number} transport The transport used for the reconnection attempt.
         * @for Temasys.Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when Socket connection sends or receives Signaling server keep-alive responses.
         * @event response
         * @param {Number} timestamp The timestamp in miliseconds when response is sent or received.
         * @param {Boolean} isSelf The flag if response is from self.
         * @param {Number} [latency] The current latency in miliseconds from receiving &quot;pong&quot;
         *   response from Signaling server after sending a &quot;ping&quot;.
         * - This is defined when &#x60;isSelf&#x60; is &#x60;false&#x60;.
         * @for Temasys.Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when Socket connection sends or receives a message.
         * @event message
         * @param {JSON} message The message.
         * @param {Boolean} isSelf The flag if message is from self.
         * @param {Error} [error] The error object.
         * - This is defined when message failed to send or parse received message.
         * @for Temasys.Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when stats retrieval state has changed.
         * @event getStatsStateChange
         * @param {String} state The current stats retrieval state.
         * - See {{#crossLink &quot;Temasys.Socket/GET_STATS_STATE_ENUM:attribute&quot;}}{{/crossLink}} for reference.
         * @param {JSON} [stats] The stats.
         * - This is defined when &#x60;state&#x60; is &#x60;SUCCESS&#x60;.
         * @param {String} stats.id The Socket connection socket.io-client ID.
         * @param {JSON} stats.messages The messages stats.
         * @param {Number} stats.messages.sent The number of messages sent from this Socket connection.
         * @param {Number} stats.messages.received The number of messages received from this Socket connection.
         * @param {Number} stats.messages.buffered The current number of messages buffered for this Socket connection to be sent.
         * @param {JSON} stats.responses The responses stats.
         * @param {JSON} stats.responses.ping The responses stats for &quot;ping&quot; response.
         * @param {Number} stats.responses.ping.sent The total number of &quot;ping&quot; response sent from this Socket connection.
         * @param {String} stats.responses.ping.timestamp The latest timestamp of the &quot;ping&quot; response sent.
         * @param {JSON} stats.responses.pong The response stats for &quot;pong&quot; response.
         * @param {Number} stats.responses.pong.received The total number of &quot;pong&quot; response received from this Socket connection.
         * @param {String} stats.responses.pong.timestamp The latest timestamp of the &quot;pong&quot; response received.
         * @param {JSON} stats.responses.latency The response latency.
         * @param {Number} stats.responses.latency.average The average response latency in miliseconds.
         * @param {Number} stats.responses.latency.lowest The lowest response latency in miliseconds.
         * @param {Number} stats.responses.latency.highest The highest response latency in miliseconds.
         * @param {Error} [error] The error object.
         * - This is defined when &#x60;state&#x60; is &#x60;FAILED&#x60;.
         * @for Temasys.Socket
         * @since 0.7.0
         */
        /**
         * Event triggered when there are exceptions thrown in this event handlers.
         * @event domError
         * @param {Error} error The error object.
         * @for Temasys.Socket
         * @since 0.7.0
         */
        (function (ref) {
          ref.on = ref._event.on;
          ref.once = ref._event.once;
          ref.off = ref._event.off;
          // Catch errors to prevent issues for socket connection
          ref._event.catch(function (error) {
            ref._event.emit(&#x27;domError&#x27;, error);
          });
        })(this);
      }
      
      /**
       * The enum of Socket connection states.
       * @attribute STATE_ENUM
       * @param {String} RECONNECT_FAILED The state when Socket connection failed to reconnect after
       *   the several specified attempts configured for the current port and transport used.
       *   At this state, the Socket connection will fallback to the next available port or transport.
       * @param {String} RECONNECT_ERROR The state when Socket connection failed to reconnect for the
       *   current attempt.
       * @param {String} RECONNECT_ATTEMPT The state when Socket connection is attempting to reconnect.
       * @param {String} RECONNECTING The state when Socket connection is reconnecting.
       * @param {String} RECONNECT The state when Socket connection has reconnected successfully.
       * @param {String} CONNECT_TIMEOUT The state when Socket connection has failed to connect after
       *   the specified timeout configured for the current port and transport.
       *   At this state, the socket connection will attempt to reconnect a few more times if reconnection is enabled.
       * @param {String} CONNECT_ERROR The state when Socket connection has errors and disconnects.
       * @param {String} CONNECT The state when Socket connection has connected successfully.
       * @param {String} DISCONNECT The state when Socket connection has been disconnected.
       * @param {String} ABORT The state when Socket connection has aborted from attempting any available
       *   ports or transports or reconnection as there is none left to reconnect or fallback with.
       * @param {String} CONSTRUCT_ERROR The state when Socket connection failed to construct.
       * @type JSON
       * @readOnly
       * @final
       * @for Temasys.Socket
       * @since 0.7.0
       */
      Socket.prototype.STATE_ENUM = {
        RECONNECT_ATTEMPT: &#x27;reconnect_attempt&#x27;,
        RECONNECT_FAILED: &#x27;reconnect_failed&#x27;,
        RECONNECT_ERROR: &#x27;reconnect_error&#x27;,
        RECONNECTING: &#x27;reconnecting&#x27;,
        RECONNECT: &#x27;reconnect&#x27;,
        CONNECT_TIMEOUT: &#x27;connect_timeout&#x27;,
        CONNECT_ERROR: &#x27;connect_error&#x27;,
        CONNECT: &#x27;connect&#x27;,
        DISCONNECT: &#x27;disconnect&#x27;,
        ABORT: &#x27;abort&#x27;,
        CONSTRUCT_ERROR: &#x27;construct_error&#x27;
      };
      
      /**
       * The enum of {{#crossLink &quot;Temasys.Socket/getStats:method&quot;}}{{/crossLink}} states.
       * @attribute GET_STATS_STATE_ENUM
       * @param {String} LOADING The state when &#x60;getStats()&#x60; is retrieving stats.
       * @param {String} SUCCESS The state when &#x60;getStats()&#x60; has retrieved stats successfully.
       * @param {String} FAILED The state when &#x60;getStats()&#x60; has failed to retrieve stats.
       * @readOnly
       * @final
       * @for Temasys.Socket
       * @since 0.7.0
       */
      Socket.prototype.GET_STATS_STATE_ENUM = {
      	LOADING: &#x27;loading&#x27;,
        SUCCESS: &#x27;success&#x27;,
        FAILED: &#x27;failed&#x27;
      };
      
      /**
       * Function to retrieve Socket connection stats.
       * @method getStats
       * @return {Promise} The Promise for function request completion.
       * @example
       *   socket.getStats().then(function (stats) {
       *     console.log(&quot;Received stats -&gt;&quot;, stats);
       *   }).catch(function (error) {
       *     console.error(&quot;Received error -&gt;&quot;, error);
       *   });
       * @for Temasys.Socket
       * @since 0.7.0
       */
      Socket.prototype.getStats = function () {
      };
      
      /**
       * Function to start socket connection.
       */
      Socket.prototype._connect = function (fn) {
        var ref = this;
        // These are stored states since sometimes the event is triggered after the restart
        var eventAttempts = 0, eventPort = null, eventTransport = null, isFnTriggered = false;
        var usePorts = ref._config.ports[ref.protocol];
        var useTransports = ref._config.transports;
      
        /**
         * Internal function to update &quot;state&quot; event.
         */
        var fnUpdate = function (state, error) {
          // Check if state is reconnect_attempt
          if (state === ref.STATE_ENUM.RECONNECT_ATTEMPT) {
            eventAttempts++;
          }
      
          ref.current.state = state;
      
          ref._event.emit(&#x27;state&#x27;, state, error || null, {
            reconnectionAttempts: eventAttempts,
            transport: eventTransport,
            port: eventPort
          });
      
          // Check state to fallback next available port or transport
          if ((state === ref.STATE_ENUM.CONNECT_TIMEOUT &amp;&amp; !ref.current.options.reconnection) ||
            state === ref.STATE_ENUM.RECONNECT_FAILED) {
            ref._disconnect();
            ref._connect(fn);
      
          // Res callback as it is successful
          } else if ([ref.STATE_ENUM.RECONNECT, ref.STATE_ENUM.CONNECT].indexOf(state) &gt; -1 &amp;&amp; !ref.current.connected) {
            ref.current.connected = true;
            if (!isFnTriggered) {
              isFnTriggered = true;
              fn(null);
            }
      
          // Res that disconnect has been made
          } else if (state === ref.STATE_ENUM.DISCONNECT) {
            if (!ref.current.connected) {
              return;
            }
            ref.current.connected = true;
      
          // Res callback has failed
          } else if ([ref.STATE_ENUM.ABORT, ref.STATE_ENUM.CONSTRUCT_ERROR].indexOf(state) &gt; -1 &amp;&amp; !isFnTriggered) {
            isFnTriggered = true;
            fn(new Error(&#x27;Failed to connect&#x27;));
          }
        };
      
        // Initial connection
        if (ref.current.port === null) {
          ref.current.port = usePorts[0];
          ref.current.transport = useTransports[0];
          ref.current.fallbackAttempts = 0;
      
        // Fallback to next available transport
        } else if (ref.current.port === usePorts[usePorts.length - 1]) {
          // Last available transport, aborted
          if (ref.current.transport === useTransports[useTransports.length - 1]) {
            return fnUpdate(ref.STATE_ENUM.ABORT);
          }
      
          ref.current.transport = useTransports[useTransports.indexOf(ref.current.transport) + 1];
          ref.current.port = usePorts[0];
          ref.current.fallbackAttempts++;
      
        // Fallback to next available port
        } else {
          ref.current.port = usePorts[usePorts.indexOf(ref.current.port) + 1];
          ref.current.fallbackAttempts++;
        }
      
        // Configure the socket.io-client options
        var useOptions = ref._config.options[ref.current.transport];
      
        useOptions = useOptions &amp;&amp; typeof useOptions === &#x27;object&#x27; ? useOptions : {};
        eventPort = ref.current.port;
        eventTransport = ref.current.transport;
      
        ref.current.attempts = 0;
        ref.current.options = {
          // Configure socket.io-client /path
          path: ref.path,
          // Configure socket.io-client reconnection option
          reconnection: useOptions.reconnection !== false,
          // Configure socket.io-client reconnection attempts. Must be less or equals to 5
          reconnectionAttempts: typeof useOptions.reconnectionAttempts === &#x27;number&#x27; &amp;&amp;
            useOptions.reconnectionAttempts &lt;= 5 ? useOptions.reconnectionAttempts :
            (ref.current.transport === &#x27;websocket&#x27; ? 2 : 4),
          // Configure socket.io-client reconnection delay
          reconnectionDelay: typeof useOptions.reconnectionDelay === &#x27;number&#x27; ? useOptions.reconnectionDelay :
            (ref.current.transport === &#x27;websocket&#x27; ? 5000 : 2000),
          // Configure socket.io-client reconnection delay max
          reconnectionDelayMax: typeof useOptions.reconnectionDelayMax === &#x27;number&#x27; ? useOptions.reconnectionDelayMax :
            (ref.current.transport === &#x27;websocket&#x27; ? 2000 : 1000),
          // Configure socket.io-client randomization factor
          randomizationFactor: typeof useOptions.randomizationFactor === &#x27;number&#x27; &amp;&amp;
            useOptions.randomizationFactor &gt;= 0 &amp;&amp; useOptions.randomizationFactor &lt;= 1 ?
            useOptions.randomizationFactor : 0.5,
          // Configure socket.io-client timeout first to consider failure
          timeout: typeof useOptions.timeout === &#x27;number&#x27; ? useOptions.timeout : 20000,
          // Configure socket.io-client transports
          transports: [ref.current.transport],
          // Let us call &#x60;.open()&#x60; manually later
          autoConnect: false,
          // Deprecated socket.io-client 1.4.x
          forceNew: true
        };
      
        var socket = null;
      
        // Catch any &quot;http:&quot; accessing errors on &quot;https:&quot; sites errors
        // Deprecated socket.io-client 1.4.x
        try {
          socket = io.connect(ref.protocol + &#x27;//&#x27; + ref.server + &#x27;:&#x27; + ref.current.port, ref.current.options);
        } catch (error) {
          return fnUpdate(ref.STATE_ENUM.CONSTRUCT_ERROR, error);
        }
      
        /**
         * Socket.io-client &quot;connect&quot; state.
         */
        socket.on(&#x27;connect&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.CONNECT);
        });
      
        /**
         * Socket.io-client &quot;reconnect&quot; state.
         */
        socket.on(&#x27;reconnect&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECT);
        });
      
        /**
         * Socket.io-client &quot;disconnect&quot; state.
         */
        socket.on(&#x27;disconnect&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.DISCONNECT);
        });
      
        /**
         * Socket.io-client &quot;connect_timeout&quot; state.
         */
        socket.on(&#x27;connect_timeout&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.CONNECT_TIMEOUT);
        });
      
        /**
         * Socket.io-client &quot;connect_error&quot; state.
         */
        socket.on(&#x27;connect_error&#x27;, function (error) {
          fnUpdate(ref.STATE_ENUM.CONNECT_ERROR, error &amp;&amp; typeof error === &#x27;object&#x27; ?
            error : new Error(error || &#x27;Connect error&#x27;));
        });
      
        /**
         * Socket.io-client &quot;reconnecting&quot; state.
         */
        socket.on(&#x27;reconnecting&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECTING);
        });
      
        /**
         * Socket.io-client &quot;reconnect_error&quot; state.
         */
        socket.on(&#x27;reconnect_error&#x27;, function (error) {
          fnUpdate(ref.STATE_ENUM.RECONNECT_ERROR, error &amp;&amp; typeof error === &#x27;object&#x27; ?
            error : new Error(error || &#x27;Reconnect error&#x27;));
        });
      
        /**
         * Socket.io-client &quot;reconnect_failed&quot; state.
         */
        socket.on(&#x27;reconnect_failed&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECT_FAILED);
        });
      
        /**
         * Socket.io-client &quot;reconnect_failed&quot; state.
         */
        socket.on(&#x27;reconnect_attempt&#x27;, function () {
          fnUpdate(ref.STATE_ENUM.RECONNECT_ATTEMPT);
        });
      
        /**
         * Socket.io-client &quot;error&quot; state.
         * Deprecated socket.io-client 1.4.x
         */
        socket.on(&#x27;error&#x27;, function (error) {
          ref._event.emit(&#x27;domError&#x27;, error &amp;&amp; typeof error === &#x27;object&#x27; ?
            error : new Error(error || &#x27;DOM exception&#x27;));
        });
      
        /**
         * Socket.io-client &quot;ping&quot; state.
         */
        socket.on(&#x27;ping&#x27;, function () {
          ref._event.emit(&#x27;response&#x27;, ref.RESPONSE_ENUM.PING, Date.now(), null);
        });
      
        /**
         * Socket.io-client &quot;pong&quot; state.
         */
        socket.on(&#x27;pong&#x27;, function (latency) {
          ref._event.emit(&#x27;response&#x27;, ref.RESPONSE_ENUM.PONG, Date.now(), latency);
        });
      
        /**
         * Socket.io-client &quot;message&quot; state.
         */
        socket.on(&#x27;message&#x27;, function (messageStr) {
          var message = JSON.parse(messageStr);
          // Cache the room ID for group messages later
          if (message.type === &#x27;inRoom&#x27;) {
            ref._buffer.cached.room = message.rid;
            ref._buffer.cached.user = message.sid;
          }
          ref._event.emit(&#x27;message&#x27;, message, null, false);
        });
      
        ref._connection = socket;
      
        if (typeof socket.connect === &#x27;function&#x27;) {
          // Catch any &quot;http:&quot; accessing errors on &quot;https:&quot; sites errors
          try {
            socket.connect();
          } catch (error) {
            fnUpdate(ref.STATE_ENUM.CONSTRUCT_ERROR, error);
          }
        }
      };
      
      /**
       * Function to stop socket connection.
       */
      Socket.prototype._disconnect = function () {
        var ref = this;
      
        if (ref._connection) {
          if (ref.current.connected) {
            ref._connection.disconnect();
          }
          ref._connection = null;
        }
      };
      
      /**
       * Function to send the next batch of queued messages.
       */
      Socket.prototype._sendNextQueue = function (fnSend) {
        var ref = this;
      
        if (ref._buffer.timer) {
          clearTimeout(ref._buffer.timer);
        }
      
        ref._buffer.timer = setTimeout(function () {
          // Ignore if there is no queue to send
          if (ref._buffer.queue[0].length === 0) {
            return;
          }
      
          var now = Date.now();
      
          if ((now - ref._buffer.timestamp) &gt; 1000) {
            Utils.forEach(ref._buffer.queue[0], function (qMessageStr, i) {
              var qMessage = JSON.parse(qMessageStr);
              // Drop outdated messages
              if ([&#x27;muteVideoEvent&#x27;, &#x27;muteAudioEvent&#x27;, &#x27;updateUserEvent&#x27;].indexOf(qMessage.type) &gt; -1 &amp;&amp;
                ref._buffer.status[qMessage.type] &gt;= qMessage.stamp) {
                ref._buffer.queue[0].splice(i, 1);
                // Trigger callback because status is outdated so it&#x27;s technically updated
                ref._buffer.queue[1].splice(i, 1)[0](null);
                return -1;
              }
            });
      
            var messageList = ref._buffer.queue[0].splice(0, 16);
            var fnList = ref._buffer.queue[1].splice(0, 16);
      
            // Send the next batch
            fnSend([{
              type: &#x27;group&#x27;,
              mid: ref._buffer.cached.user,
              rid: ref._buffer.cached.room,
              list: messageList
      
            }, function (error) {
              Utils.forEach(fnList, function (fnItem, i) {
                ref._event.emit(&#x27;message&#x27;, JSON.parse(messageList[i]), error || null, true);
                fnItem(error || null);
              });
            }]);
            ref._buffer.timestamp = now;
            ref._sendNextQueue(fnSend);
          }
        }, 1000);
      };
      
      /**
       * Function to send messages.
       */
      Socket.prototype._send = function (message, fn) {
        var ref = this;
      
        /**
         * Internal function to send message.
         */
        var fnSend = function (item) {
          if (!(ref._connection &amp;&amp; ref.current.connected)) {
            var notOpenError = new Error(&#x27;Failed to send message as socket is not connected&#x27;);
            ref._event.emit(&#x27;message&#x27;, item[0], notOpenError, true);
            return item[1](notOpenError);
          }
      
          // &quot;compress&quot; functionality may not work until server has implemented it
          ref._connection.compress(ref.compressData).send(item[0], function () {
            // TODO: Server to send ack? Not documenting this as it might not be available yet
            ref._event.emit(&#x27;messageAck&#x27;, item[0]);
          });
      
          ref._event.emit(&#x27;message&#x27;, item[0], null, true);
          item[1](null);
        };
      
        // Priority channel which should not be buffered in which server should queue that.
        if ([&#x27;joinRoom&#x27;, &#x27;enter&#x27;, &#x27;restart&#x27;, &#x27;welcome&#x27;, &#x27;endOfCandidates&#x27;].indexOf(message.type) &gt; -1) {
          fnSend([message, typeof fn === &#x27;function&#x27; ? fn : function () {}]);
      
        // Messaging channel for broadcast or info messages to buffer which server would drop
        } else if ([&#x27;private&#x27;, &#x27;roomLockEvent&#x27;, &#x27;stream&#x27;, &#x27;public&#x27;, &#x27;updateUserEvent&#x27;,
          &#x27;muteAudioEvent&#x27;, &#x27;muteVideoEvent&#x27;].indexOf(message.type) &gt; -1) {
      
          setTimeout(function () {
            var now = Date.now();
      
            // Set the stamp value
            if ([&#x27;muteVideoEvent&#x27;, &#x27;muteAudioEvent&#x27;, &#x27;updateUserEvent&#x27;].indexOf(message.type) &gt; -1) {
              ref._buffer.status[message.type] = now;
              message.stamp = now;
            }
      
            if ((now - ref._buffer.timestamp) &gt; (message.type === &#x27;private&#x27; ? 120 : 1000)) {
              fnSend([message, typeof fn === &#x27;function&#x27; ? fn : function () {}]);
              ref._buffer.timestamp = now;
              ref._sendNextQueue(fnSend);
              return;
            }
      
            // Prevent delayed Room locks
            if (message.type === &#x27;roomLockEvent&#x27;) {
              var droppedError = new Error(&#x27;Unable to send command to lock Room due to messages buffer&#x27;);
              ref._emit(&#x27;message&#x27;, message, droppedError, true);
              (typeof fn === &#x27;function&#x27; ? fn : function () {})(droppedError);
              return;
            }
      
            ref._buffer.queue[0].push(JSON.stringify(message));
            ref._buffer.queue[1].push(typeof fn === &#x27;function&#x27; ? fn : function () {});
            ref._sendNextQueue(fnSend);
          }, 0);
      
        // Invalid messages which is not part of the SM protocol
        } else {
          var invalidError = new Error(&#x27;Invalid message type provided&#x27;);
          ref._event.emit(&#x27;message&#x27;, message, invalidError, true);
          if (typeof fn === &#x27;function&#x27;) {
            fn(invalidError);
          }
        }
      };
          </pre>
      </div>
    </div>
   </section>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SkylinkJS 0.6.17</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" /><small>Version: 0.6.17</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.com.sg/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.com.sg/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.com.sg/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="http://developer.temasys.com.sg/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.com.sg/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/socket-channel.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Function that sends Socket message to Signaling.
 * @method _socketSendMessage
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._socketSendMessage = function(message) {
  var self = this;

  // Check and prevent sending message if socket connection is not connected
  if (!self._socket.connected) {
    return log.warn([message.target || &#x27;(all)&#x27;, &#x27;Socket&#x27;, message.type,
      &#x27;Dropping of message as Socket connection is not opened -&gt;&#x27;], message);
  }

  // Check if message matches group list
  if (self._socket.queue.types.indexOf(message.type) &gt; -1) {
    // &quot;Queuing&quot; mechanism just simply send if interval has reached.
    // It does go by order, it&#x27;s kinda like UDP and messages may be sent in unordered manner
    // Whatever available broadcasted messages that can be sent, just be sent
    // Check if timestamp is within the specified interval
    if (!(self._socket.queue.timestamp &amp;&amp; ((new Date ()).getTime() - self._socket.queue.timestamp) &lt;= self._socket.queue.interval)) {
      // Clear existing timeout intervals since the current item is sent.
      // The rest of the queue items can wait. Sadz
      if (self._socket.queue.fn) {
        clearTimeout(self._socket.queue.fn);
      }
      self._socket.socket.send(JSON.stringify(message));
      // Trigger &#x60;incomingMessage&#x60; event if &quot;public&quot; type
      if (message.type === &#x27;public&#x27;) {
        self._trigger(&#x27;incomingMessage&#x27;, {
          content: message.data,
          isPrivate: false,
          targetPeerId: null,
          listOfPeers: Object.keys(self._peerInformations),
          isDataChannel: false,
          senderPeerId: self._user.id
        }, self._user.id, self.getPeerInfo(), true);
      // Update socket message timestamp event
      } else if (message.type !== &#x27;stream&#x27;) {
        self._user.timestamps[message.type] = message.stamp;
      }
      // Update socket messages queue timestamp
      self._socket.queue.timestamp = (new Date()).getTime();
      // Check if there is a current queue and start timing if so
      if (self._socket.queue.messages.length &gt; 0) {
        self._socketSendMessageProcessNextQueue();
      }

    // Time to queue the socket messages
    } else {
      log.debug([&#x27;(all)&#x27;, &#x27;Socket&#x27;, message.type, &#x27;Queueing message -&gt;&#x27;], message);
      self._socket.queue.messages.push(message);
      self._socketSendMessageProcessNextQueue();
    }
  // Send direct message without queuing.
  // Do note that the Signaling messages does throttling drops hence the queuing of broadcasted messages
  } else {
    log.debug([message.target || &#x27;(all)&#x27;, &#x27;Socket&#x27;, message.type, &#x27;Sending message -&gt;&#x27;], message);
    self._socket.socket.send(JSON.stringify(message));
  }
};

/**
 * Function that sends Socket message to Signaling.
 * @method _socketSendMessage
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._socketSendMessageProcessNextQueue = function () {
  var self = this;

  // Append socket queue if it does exists
  if (!self._socket.queue.fn) {
    self._socket.queue.fn = setTimeout(function () {
      // Clear socket queue interval
      self._socket.queue.fn = null;
      // Check if socket connection is opened
      if (!self._socket.connected) {
        log.warn(&#x27;Dropping queue stack of messages as socket connection is closed -&gt;&#x27;, self._socket.queue.messages);
        return;
      }
      // Check if there is any queue stack at all first
      if (self._socket.queue.messages.length === 0) {
        return;
      }

      var currentStack = [];

      // Remove outdated messages
      for (var i = 0; i &lt; self._socket.queue.messages.length; i++) {
        var messageItem = self._socket.queue.messages[i];
        // Check if it is outdated before dropping them
        if ([&#x27;muteAudioEvent&#x27;, &#x27;muteVideoEvent&#x27;, &#x27;updateUserEvent&#x27;].indexOf(messageItem.type) &gt; -1 &amp;&amp;
          self._user.timestamps[messageItem.type] &gt;= messageItem.stamp) {
          self._socket.queue.messages.splice(i, 1);
          i--;
        } else if (currentStack.length &lt;= self._socket.queue.throughput) {
          if ([&#x27;muteAudioEvent&#x27;, &#x27;muteVideoEvent&#x27;, &#x27;updateUserEvent&#x27;].indexOf(messageItem.type) &gt; -1) {
            self._user.timestamps[messageItem.type] = messageItem.stamp;
          }
          self._socket.queue.messages.splice(i, 1);
          i--;
          currentStack.push(JSON.stringify(messageItem));
        }
      }

      // Send current queue of stack messages
      log.debug([&#x27;(all)&#x27;, &#x27;Socket&#x27;, &#x27;group&#x27;, &#x27;Sending queue stack -&gt;&#x27;], currentStack);

      self._socket.socket.send(JSON.stringify({
        type: self._SIG_MESSAGE_TYPE.GROUP,
        lists: currentStack,
        mid: self._user.id,
        rid: self._user.room.session.rid
      }));
      self._socket.queue.timestamp = (new Date()).getTime();

      // Trigger &#x60;incomingMessage&#x60; events
      for (var j = 0; j &lt; currentStack.length; j++) {
        if (currentStack[j].type === &#x27;public&#x27;) {
          self._trigger(&#x27;incomingMessage&#x27;, {
            content: currentStack[j].data,
            isPrivate: false,
            targetPeerId: null,
            listOfPeers: Object.keys(self._peerInformations),
            isDataChannel: false,
            senderPeerId: self._user.id
          }, self._user.id, self.getPeerInfo(), true);
        }
      }

      // Process next queue
      self._socketSendMessageProcessNextQueue();

    }, self._socket.queue.interval);
  }
};

/**
 * Function that establishes the Socket connection to Signaling.
 * @method _socketAttemptConnection
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._socketAttemptConnection = function (callback) {
  var self = this;
  var socketPorts = self._socket.ports[self._socket.session.protocol];
  // The &#x60;socketError&#x60; and &#x60;channelRetry&#x60; fallback state
  var fallbackState = null;

  // State when there is no existing current port
  if (self._socket.session.port === null) {
    self._socket.session.port = socketPorts[0];
    self._socket.session.finalAttempts = 0;
    self._socket.session.retries = 0;
    // Set the initial fallback state
    fallbackState = self.SOCKET_FALLBACK.NON_FALLBACK;

  // State when current port has reached the final last port
  } else if (ports.indexOf(self._signalingServerPort) === ports.length - 1) {
    // Let&#x27;s attempt to use Polling transports from the first port
    if (self._socket.session.transportType === &#x27;WebSocket&#x27;) {
      self._socket.session.transportType = &#x27;Polling&#x27;;
      self._socket.session.port = socketPorts[0];
    // Let&#x27;s attempt with another last 4 rounds
    } else {
      self._socket.session.finalAttempts++;
    }
  // State to go to the next port
  } else {
    self._socket.session.port = socketPorts[socketPorts.indexOf(self._socket.session.port) + 1];
  }

  // Socket.io-client options
  // Handle socket.io-client options for WebSocket transports (by default)
  self._socket.session.options = {
    forceNew: true,
    reconnection: true,
    timeout: self._options.socketTimeout,
    reconnectionAttempts: 2,
    reconnectionDelayMax: 5000,
    reconnectionDelay: 1000,
    transports: [&#x27;websocket&#x27;]
  };

  // Handle socket.io-client options for Polling transports
  if (self._socket.session.transportType === &#x27;Polling&#x27;) {
    self._socket.session.options.reconnectionDelayMax = 1000;
    self._socket.session.options.reconnectionAttempts = 4;
    self._socket.session.options.transports = [&#x27;xhr-polling&#x27;, &#x27;jsonp-polling&#x27;, &#x27;polling&#x27;];
  }

  // Configure the non-initial fallback types
  if (fallbackState === null) {
    fallbackState = self._socket.session.protocol === &#x27;http:&#x27; ?
    // Configure the HTTP protocol Polling or WebSocket type
      (self._socket.session.transportType === &#x27;Polling&#x27; ? self.SOCKET_FALLBACK.LONG_POLLING :
      self.SOCKET_FALLBACK.FALLBACK_PORT) : (self._socket.session.transportType === &#x27;Polling&#x27; ?
    // Configure the HTTPS protocol Polling or WebSocket type
      self.SOCKET_FALLBACK.LONG_POLLING_SSL : self.SOCKET_FALLBACK.FALLBACK_SSL_PORT);

    self._socket.session.retries++;

    // Trigger &#x60;socketError&#x60; event for RECONNECTION_ATTEMPT
    self._trigger(&#x27;socketError&#x27;, self.SOCKET_ERROR.RECONNECTION_ATTEMPT, null,
      fallbackState, self._socketGetSession());
    // Trigger &#x60;channelRetry&#x60; event for the first failure, not the reconnect attempts retries
    self._trigger(&#x27;channelRetry&#x27;, fallbackState, self._socket.session.retries, self._socketGetSession());
  }

  // Construct Signaling server path
  self._socket.session.path = self._socket.session.protocol + &#x27;//&#x27; + self._socket.server + &#x27;:&#x27; +
    self._socket.session.port; //&#x27;http://ec2-52-8-93-170.us-west-1.compute.amazonaws.com:6001&#x27;;

  // Use the custom Signaling server url
  if (typeof self._options.socketServer === &#x27;string&#x27;) {
    self._socket.session.path = self._socket.session.protocol + &#x27;//&#x27; + self._options.socketServer + &#x27;:&#x27; +
      self._socket.session.port;
  }

  // Disconnect any existing socket connection
  if (self._socket.socket) {
    self._socket.removeAllListeners();
    self._socket.disconnect();
    self._socket = null;
  }

  self._socket.connected = false;

  log.log(&#x27;Opening socket connection -&gt;&#x27;, self._socketGetSession());

  self._socket.socket = io.connect(self._socket.session.path, self._socket.session.options);

  // socket.io-client &#x60;reconnect_attempt&#x60; event
  // Triggered each time socket.io-client attempts to reconnect
  self._socket.socket.on(&#x27;reconnect_attempt&#x27;, function (attempt) {
    self._socket.session.retries++;
    // Trigger &#x60;channelRetry&#x60; event
    self._trigger(&#x27;channelRetry&#x27;, fallbackState, self._socket.session.retries, self._socketGetSession());
  });

  // socket.io-client &#x60;reconnect_attempt&#x60; event
  // Triggered each time socket.io-client fails to reconnect after all the maximum attempt configured
  self._socket.socket.on(&#x27;reconnect_failed&#x27;, function () {
    // Check if its the initial state, return as first connection failure
    if (fallbackState === self.SOCKET_FALLBACK.NON_FALLBACK) {
      // Trigger &#x60;socketError&#x60; event for CONNECTION FAILED
      self._trigger(&#x27;socketError&#x27;, self.SOCKET_ERROR.CONNECTION_FAILED,
        new Error(&#x27;Failed connection with transport &quot;&#x27; + self._socket.session.transportType +
        &#x27;&quot; and port &#x27; + self._socket.session.port + &#x27;.&#x27;), fallbackState, self._socketGetSession());
    // Else trigger as subsequent connection failure
    } else {
      // Trigger &#x60;socketError&#x60; event for RECONNECTION_FAILED
      self._trigger(&#x27;socketError&#x27;, self.SOCKET_ERROR.RECONNECTION_FAILED,
        new Error(&#x27;Failed reconnection with transport &quot;&#x27; + self._socket.session.transportType +
        &#x27;&quot; and port &#x27; + self._socket.session.port + &#x27;.&#x27;), fallbackState, self._socketGetSession());
    }
    // Check if it has reached the final attempt limit before fallbacking to the next available port / transport type
    if (self._socket.session.finalAttempts &lt; 4) {
      self._socketAttemptConnection();
    // Check if it has reached the final attempt limit
    } else {
      // Trigger &#x60;socketError&#x60; event for RECONNECTION_ABORTED. Not more attempts to go on to retry.
      self._trigger(&#x27;socketError&#x27;, self.SOCKET_ERROR.RECONNECTION_ABORTED, new Error(&#x27;Reconnection aborted as &#x27; +
        &#x27;there no more available ports, transports and final attempts left.&#x27;), fallbackState, self._socketGetSession());
      callback(new Error(&#x27;Reconnection aborted.&#x27;));
    }
  });

  // socket.io-client &#x60;reconnect_attempt&#x60; event
  // Triggered each time socket.io-client has connected
  self._socket.socket.on(&#x27;connect&#x27;, function () {
    if (!self._socket.connected) {
      log.log(&#x27;Socket channel opened for port @&#x27; + self._socket.session.port + &#x27;.&#x27;);
      self._socket.connected = true;
      // Trigger &#x60;channelOpen&#x60; event
      self._trigger(&#x27;channelOpen&#x27;, clone(self._socketSession));
      callback();
    }
  });

  // socket.io-client &#x60;reconnect&#x60; event
  // Triggered each time socket.io-client has connected after several reconnection attempts
  self._socket.socket.on(&#x27;reconnect&#x27;, function () {
    if (!self._socket.connected) {
      log.log(&#x27;Socket channel opened after reconnection attempt (&#x27; + self._socket.session.retries +
        &#x27;) for port @&#x27; + self._socket.session.port + &#x27;.&#x27;);
      self._socket.connected = true;
      // Trigger &#x60;channelOpen&#x60; event
      self._trigger(&#x27;channelOpen&#x27;, self._socketGetSession());
      callback();
    }
  });

  // socket.io-client &#x60;error&#x60; event
  // Triggered when socket.io-client event handler errors like &#x60;peerJoined&#x60; event from the call-stack.
  // Can be xhr-poll errors
  self._socket.socket.on(&#x27;error&#x27;, function(error) {
    // Disconnect Polling errors
    if (error.message.indexOf(&#x27;xhr post error&#x27;) &gt; -1) {
      log.error(&#x27;Socket channel Polling errors and connection is unstable. Disconnecting..&#x27;);
      // Trigger &#x60;socketError&#x60; event
      self._trigger(&#x27;socketError&#x27;, self.SOCKET_ERROR.CONNECTION_ABORTED,
        new Error(&#x27;Failed reconnection with transport &quot;&#x27; + self._socket.session.transportType +
        &#x27;&quot; and port &#x27; + self._socket.session.port + &#x27;.&#x27;), fallbackState, self._socketGetSession());
      // Close socket connection
      self._socketClose();
      return;
    }
    log.error(&#x27;App exception occurred. Please check your event handlers for code errors. -&gt;&#x27;, error);
    // Trigger &#x60;channelError&#x60; event
    self._trigger(&#x27;channelError&#x27;, error, self._socketGetSession());
  });

  // socket.io-client &#x60;error&#x60; event
  // Triggered when socket.io-client is disconnected abruptly
  self._socket.socket.on(&#x27;disconnect&#x27;, function() {
    if (self._socket.connected) {
      log.warn(&#x27;Socket connection closed abruptly.&#x27;);
      self._socket.connected = false;
      // Trigger &#x60;channelClose&#x60; event
      self._trigger(&#x27;channelClose&#x27;, self._socketGetSession());
      // Check if User is in Room and Socket connection was disconnected
      if (self._user.room.connected) {
        self.leaveRoom(false);
        self._trigger(&#x27;sessionDisconnect&#x27;, self._user.id, self.getPeerInfo());
      }
    }
  });

  // socket.io-client &#x60;message&#x60; event
  // Triggered when socket.io-client receives message from Peers
  self._socket.socket.on(&#x27;message&#x27;, function(messageStr) {
    var message = JSON.parse(messageStr);
    if (message.type === self._SIG_MESSAGE_TYPE.GROUP) {
      log.debug(&#x27;Bundle of &#x27; + message.lists.length + &#x27; messages&#x27;);
      for (var i = 0; i &lt; message.lists.length; i++) {
        var indiMessage = JSON.parse(message.lists[i]);
        self._processSigMessage(indiMessage);
        self._trigger(&#x27;channelMessage&#x27;, indiMessage, self._socketGetSession());
      }
    } else {
      self._processSigMessage(message);
      self._trigger(&#x27;channelMessage&#x27;, message, clone(self._socketSession));
    }
  });
};

/**
 * Function that starts the Socket connection.
 * @method _socketOpen
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._socketOpen = function (callback) {
  var self = this;

  if (self._socket.socket) {
    self._socketClose();
  }

  self._socket.session.port = null;
  self._socket.session.protocol = self._options.forceSSL ? &#x27;https:&#x27; : window.location.protocol;
  // IE &lt; 9 doesn&#x27;t support WebSocket
  self._socket.session.transportType = !window.WebSocket ? &#x27;Polling&#x27; : &#x27;WebSocket&#x27;;
  self._socket.session.retries = 0;
  self._socket.session.finalAttempts = 0;
  self._socket.session.fallbackState = null;

  // Begin with a websocket connection
  self._socketAttemptConnection(callback);
};

/**
 * Function that returns the Socket session information.
 * @method _socketGetSession
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._socketGetSession = function () {
  var self = this;
  return {
    finalAttempts: self._socket.session.finalAttempts,
    serverUrl: self._socket.session.path,
    socketOptions: clone(self._socket.session.options),
    attempts: self._socket.session.retries,
    transportType: self._socket.session.transportType
  };
};

/**
 * Function that stops the Socket connection.
 * @method _socketClose
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._socketClose = function() {
  var self = this;

  // Remove all current event listeners
  if (self._socket.socket) {
    self._socket.socket.removeAllListeners();
  }

  // Close connection or return as close if state is connected
  if (self._socket.connected) {
    if (self._socket.socket) {
      self._socket.socket.disconnect();
    }

    self._socket.connected = false;

    self._trigger(&#x27;channelClose&#x27;, self._socketGetSession());
  }

  self._socket.socket = null;
};
    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

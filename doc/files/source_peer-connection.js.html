<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SkylinkJS 0.6.17</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" /><small>Version: 0.6.17</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.com.sg/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.com.sg/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.com.sg/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="http://developer.temasys.com.sg/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.com.sg/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/peer-connection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
 * Function that refresh connections.
 * @method _refreshPeerConnection
 * @private
 * @for Skylink
 * @since 0.6.15
 */
Skylink.prototype._refreshPeerConnection = function(listOfPeers, doIceRestart, callback) {
  var self = this;
  var listOfPeerRestarts = [];
  var error = &#x27;&#x27;;
  var listOfPeerRestartErrors = {};

  // To fix jshint dont put functions within a loop
  var refreshSinglePeerCallback = function (peerId) {
    return function (error) {
      if (listOfPeerRestarts.indexOf(peerId) === -1) {
        if (error) {
          log.error([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Failed restarting for peer&#x27;], error);
          listOfPeerRestartErrors[peerId] = error;
        }
        listOfPeerRestarts.push(peerId);
      }

      if (listOfPeerRestarts.length === listOfPeers.length) {
        if (typeof callback === &#x27;function&#x27;) {
          log.log([null, &#x27;PeerConnection&#x27;, null, &#x27;Invoked all peers to restart. Firing callback&#x27;]);

          if (Object.keys(listOfPeerRestartErrors).length &gt; 0) {
            callback({
              refreshErrors: listOfPeerRestartErrors,
              listOfPeers: listOfPeers
            }, null);
          } else {
            callback(null, {
              listOfPeers: listOfPeers
            });
          }
        }
      }
    };
  };

  var refreshSinglePeer = function(peerId, peerCallback){
    if (!self._peerConnections[peerId]) {
      error = &#x27;There is currently no existing peer connection made &#x27; +
        &#x27;with the peer. Unable to restart connection&#x27;;
      log.error([peerId, null, null, error]);
      peerCallback(error);
      return;
    }

    log.log([peerId, &#x27;PeerConnection&#x27;, null, &#x27;Restarting peer connection&#x27;]);

    // do a hard reset on variable object
    self._restartPeerConnection(peerId, doIceRestart, peerCallback);
  };

  if(!self._hasMCU) {
    var i;

    for (i = 0; i &lt; listOfPeers.length; i++) {
      var peerId = listOfPeers[i];

      if (Object.keys(self._peerConnections).indexOf(peerId) &gt; -1) {
        refreshSinglePeer(peerId, refreshSinglePeerCallback(peerId));
      } else {
        error = &#x27;Peer connection with peer does not exists. Unable to restart&#x27;;
        log.error([peerId, &#x27;PeerConnection&#x27;, null, error]);
        refreshSinglePeerCallback(peerId)(error);
      }
    }
  } else {
    self._restartMCUConnection(callback, doIceRestart);
  }
};

/**
 * Function that retrieves Peer connection stats.
 * @method _retrieveStats
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._retrieveStats = function (peerId, callback) {
  var self = this;

  log.debug([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieivng connection status&#x27;]);

  var pc = self._peerConnections[peerId];
  var result = {
    raw: null,
    connection: {
      iceConnectionState: pc.iceConnectionState,
      iceGatheringState: pc.iceGatheringState,
      signalingState: pc.signalingState,
      remoteDescription: {
        type: pc.remoteDescription ? pc.remoteDescription.type || null : null,
        sdp : pc.remoteDescription ? pc.remoteDescription.sdp || null : null
      },
      localDescription: {
        type: pc.localDescription ? pc.localDescription.type || null : null,
        sdp : pc.localDescription ? pc.localDescription.sdp || null : null
      },
      candidates: clone(self._gatheredCandidates[peerId] || {
        sending: { host: [], srflx: [], relay: [] },
        receiving: { host: [], srflx: [], relay: [] }
      }),
      dataChannels: {}
    },
    audio: {
      sending: {
        ssrc: null,
        bytes: 0,
        packets: 0,
        // Should not be for sending?
        packetsLost: 0,
        rtt: 0,
        // Should not be for sending?
        jitter: 0,
        // Should not be for sending?
        jitterBufferMs: null,
        codec: self._getSDPSelectedCodec(peerId, pc.remoteDescription, &#x27;audio&#x27;),
        nacks: null,
        inputLevel: null,
        echoReturnLoss: null,
        echoReturnLossEnhancement: null,
        totalBytes: 0,
        totalPackets: 0,
        totalPacketsLost: 0,
        totalNacks: null
      },
      receiving: {
        ssrc: null,
        bytes: 0,
        packets: 0,
        packetsLost: 0,
        packetsDiscarded: 0,
        fractionLost: 0,
        nacks: null,
        jitter: 0,
        jitterBufferMs: null,
        codec: self._getSDPSelectedCodec(peerId, pc.remoteDescription, &#x27;audio&#x27;),
        outputLevel: null,
        totalBytes: 0,
        totalPackets: 0,
        totalPacketsLost: 0,
        totalNacks: null
      }
    },
    video: {
      sending: {
        ssrc: null,
        bytes: 0,
        packets: 0,
        // Should not be for sending?
        packetsLost: 0,
        rtt: 0,
        // Should not be for sending?
        jitter: 0,
        // Should not be for sending?
        jitterBufferMs: null,
        codec: self._getSDPSelectedCodec(peerId, pc.remoteDescription, &#x27;video&#x27;),
        frameWidth: null,
        frameHeight: null,
        framesDecoded: null,
        framesCorrupted: null,
        framesDropped: null,
        framesPerSecond: null,
        framesInput: null,
        frames: null,
        frameRateEncoded: null,
        frameRate: null,
        frameRateInput: null,
        frameRateMean: null,
        frameRateStdDev: null,
        nacks: null,
        plis: null,
        firs: null,
        slis: null,
        qpSum: null,
        totalBytes: 0,
        totalPackets: 0,
        totalPacketsLost: 0,
        totalNacks: null,
        totalPlis: null,
        totalFirs: null,
        totalSlis: null,
        totalFrames: null
      },
      receiving: {
        ssrc: null,
        bytes: 0,
        packets: 0,
        packetsDiscarded: 0,
        packetsLost: 0,
        fractionLost: 0,
        jitter: 0,
        jitterBufferMs: null,
        codec: self._getSDPSelectedCodec(peerId, pc.remoteDescription, &#x27;video&#x27;),
        frameWidth: null,
        frameHeight: null,
        framesDecoded: null,
        framesCorrupted: null,
        framesPerSecond: null,
        framesDropped: null,
        framesOutput: null,
        frames: null,
        frameRateMean: null,
        frameRateStdDev: null,
        nacks: null,
        plis: null,
        firs: null,
        slis: null,
        e2eDelay: null,
        totalBytes: 0,
        totalPackets: 0,
        totalPacketsLost: 0,
        totalNacks: null,
        totalPlis: null,
        totalFirs: null,
        totalSlis: null,
        totalFrames: null
      }
    },
    selectedCandidate: {
      local: {
        ipAddress: null,
        candidateType: null,
        portNumber: null,
        transport: null, 
        turnMediaTransport: null
      },
      remote: {
        ipAddress: null,
        candidateType: null,
        portNumber: null,
        transport: null
      },
      consentResponses: {
        received: null,
        sent: null,
        totalReceived: null,
        totalSent: null
      },
      consentRequests: {
        received: null,
        sent: null,
        totalReceived: null,
        totalSent: null
      },
      responses: {
        received: null,
        sent: null,
        totalReceived: null,
        totalSent: null
      },
      requests: {
        received: null,
        sent: null,
        totalReceived: null,
        totalSent: null
      }
    },
    certificate: {
      local: self._getSDPFingerprint(peerId, pc.localDescription),
      remote: self._getSDPFingerprint(peerId, pc.remoteDescription),
      dtlsCipher: null,
      srtpCipher: null
    }
  };

  for (var channelProp in self._dataChannels[peerId]) {
    if (self._dataChannels[peerId].hasOwnProperty(channelProp) &amp;&amp; self._dataChannels[peerId][channelProp]) {
      result.connection.dataChannels[self._dataChannels[peerId][channelProp].channel.label] = {
        label: self._dataChannels[peerId][channelProp].channel.label,
        readyState: self._dataChannels[peerId][channelProp].channel.readyState,
        channelType: channelProp === &#x27;main&#x27; ? self.DATA_CHANNEL_TYPE.MESSAGING : self.DATA_CHANNEL_TYPE.DATA,
        currentTransferId: self._dataChannels[peerId][channelProp].transferId || null
      };
    }
  }

  var loopFn = function (obj, fn) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) &amp;&amp; obj[prop]) {
        fn(obj[prop], prop);
      }
    }
  };

  var formatCandidateFn = function (candidateDirType, candidate) {
    result.selectedCandidate[candidateDirType].ipAddress = candidate.ipAddress;
    result.selectedCandidate[candidateDirType].candidateType = candidate.candidateType;
    result.selectedCandidate[candidateDirType].portNumber = typeof candidate.portNumber !== &#x27;number&#x27; ?
      parseInt(candidate.portNumber, 10) || null : candidate.portNumber;
    result.selectedCandidate[candidateDirType].transport = candidate.transport;
  };

  pc.getStats(null, function (stats) {
    log.debug([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieval success -&gt;&#x27;], stats);

    result.raw = stats;

    if (window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
      loopFn(stats, function (obj, prop) {
        var dirType = &#x27;&#x27;;

        // Receiving/Sending RTP packets
        if (prop.indexOf(&#x27;inbound_rtp&#x27;) === 0 || prop.indexOf(&#x27;outbound_rtp&#x27;) === 0) {
          dirType = prop.indexOf(&#x27;inbound_rtp&#x27;) === 0 ? &#x27;receiving&#x27; : &#x27;sending&#x27;;

          if (!self._peerStats[peerId][prop]) {
            self._peerStats[peerId][prop] = obj;
          }

          result[obj.mediaType][dirType].bytes = self._parseConnectionStats(self._peerStats[peerId][prop],
            obj, dirType === &#x27;receiving&#x27; ? &#x27;bytesReceived&#x27; : &#x27;bytesSent&#x27;);
          result[obj.mediaType][dirType].totalBytes = parseInt(
            (dirType === &#x27;receiving&#x27; ? obj.bytesReceived : obj.bytesSent) || &#x27;0&#x27;, 10);
          result[obj.mediaType][dirType].packets = self._parseConnectionStats(self._peerStats[peerId][prop],
            obj, dirType === &#x27;receiving&#x27; ? &#x27;packetsReceived&#x27; : &#x27;packetsSent&#x27;);
          result[obj.mediaType][dirType].totalPackets = parseInt(
            (dirType === &#x27;receiving&#x27; ? obj.packetsReceived : obj.packetsSent) || &#x27;0&#x27;, 10);
          result[obj.mediaType][dirType].ssrc = obj.ssrc;
          
          if (obj.mediaType === &#x27;video&#x27;) {
            result.video[dirType].frameRateMean = obj.framerateMean || 0;
            result.video[dirType].frameRateStdDev = obj.framerateStdDev || 0;
            result.video[dirType].framesDropped = typeof obj.framesDropped === &#x27;number&#x27; ? obj.framesDropped :
              (typeof obj.droppedFrames === &#x27;number&#x27; ? obj.droppedFrames : null);
            result.video[dirType].framesCorrupted = typeof obj.framesCorrupted === &#x27;number&#x27; ? obj.framesCorrupted : null;
            result.video[dirType].framesPerSecond = typeof obj.framesPerSecond === &#x27;number&#x27; ? obj.framesPerSecond : null;

            if (dirType === &#x27;sending&#x27;) {
              result.video[dirType].framesEncoded = typeof obj.framesEncoded === &#x27;number&#x27; ? obj.framesEncoded : null;
              result.video[dirType].frames = typeof obj.framesSent === &#x27;number&#x27; ? obj.framesSent : null;
            } else {
              result.video[dirType].framesDecoded = typeof obj.framesDecoded === &#x27;number&#x27; ? obj.framesDecoded : null;
              result.video[dirType].frames = typeof obj.framesReceived === &#x27;number&#x27; ? obj.framesReceived : null;
            }
          }

          if (dirType === &#x27;receiving&#x27;) {
            obj.packetsDiscarded = (typeof obj.packetsDiscarded === &#x27;number&#x27; ? obj.packetsDiscarded :
              obj.discardedPackets) || 0;
            obj.packetsLost = typeof obj.packetsLost === &#x27;number&#x27; ? obj.packetsLost : 0;

            result[obj.mediaType].receiving.packetsLost = self._parseConnectionStats(self._peerStats[peerId][prop],
              obj, &#x27;packetsLost&#x27;);
            result[obj.mediaType].receiving.packetsDiscarded = self._parseConnectionStats(self._peerStats[peerId][prop],
              obj, &#x27;packetsDiscarded&#x27;);
            result[obj.mediaType].receiving.totalPacketsDiscarded = obj.packetsDiscarded;
            result[obj.mediaType].receiving.totalPacketsLost = obj.packetsLost;
          }

          self._peerStats[peerId][prop] = obj;

        // Sending RTP packets lost
        } else if (prop.indexOf(&#x27;inbound_rtcp&#x27;) === 0 || prop.indexOf(&#x27;outbound_rtcp&#x27;) === 0) {
          dirType = prop.indexOf(&#x27;inbound_rtp&#x27;) === 0 ? &#x27;receiving&#x27; : &#x27;sending&#x27;;

          if (!self._peerStats[peerId][prop]) {
            self._peerStats[peerId][prop] = obj;
          }

          if (dirType === &#x27;sending&#x27;) {
            result[obj.mediaType].sending.rtt = obj.mozRtt || 0;
            result[obj.mediaType].sending.targetBitrate = typeof obj.targetBitrate === &#x27;number&#x27; ? obj.targetBitrate : 0;
          } else {
            result[obj.mediaType].receiving.jitter = obj.jitter || 0;
          }

          self._peerStats[peerId][prop] = obj;

        // Candidates
        } else if (obj.nominated &amp;&amp; obj.selected) {
          formatCandidateFn(&#x27;remote&#x27;, stats[obj.remoteCandidateId]);
          formatCandidateFn(&#x27;local&#x27;, stats[obj.localCandidateId]);
        }
      });

    } else if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
      var tracks = [];

      if (pc.getRemoteStreams().length &gt; 0) {
        tracks = tracks.concat(pc.getRemoteStreams()[0].getTracks());
      }

      if (pc.getLocalStreams().length &gt; 0) {
        tracks = tracks.concat(pc.getLocalStreams()[0].getTracks());
      }

      loopFn(tracks, function (track) {
        loopFn(stats, function (obj, prop) {
          if (obj.type === &#x27;track&#x27; &amp;&amp; obj.trackIdentifier === track.id) {
            var dirType = obj.remoteSource ? &#x27;receiving&#x27; : &#x27;sending&#x27;;
            var mediaType = track.kind;

            if (mediaType === &#x27;audio&#x27;) {
              result[mediaType][dirType][dirType === &#x27;sending&#x27; ? &#x27;inputLevel&#x27; : &#x27;outputLevel&#x27;] = obj.audioLevel;
              if (dirType === &#x27;sending&#x27;) {
                result[mediaType][dirType].echoReturnLoss = obj.echoReturnLoss;
                result[mediaType][dirType].echoReturnLossEnhancement = obj.echoReturnLossEnhancement;
              }
            } else {
              result[mediaType][dirType].frames = self._parseConnectionStats(self._peerStats[peerId][subprop],
                streamObj,dirType === &#x27;sending&#x27; ? obj.framesSent : obj.framesReceived);
              result[mediaType][dirType].framesDropped = obj.framesDropped;
              result[mediaType][dirType].framesDecoded = obj.framesDecoded;
              result[mediaType][dirType].framesCorrupted = obj.framesCorrupted;
              result[mediaType][dirType].framesPerSecond = obj.framesPerSecond;
              result[mediaType][dirType].frameHeight = obj.frameHeight || null;
              result[mediaType][dirType].frameWidth = obj.frameWidth || null;
              result[mediaType][dirType].totalFrames = dirType === &#x27;sending&#x27; ? obj.framesSent : obj.framesReceived;
            }

            loopFn(stats, function (streamObj, subprop) {
              if (streamObj.mediaTrackId === obj.id &amp;&amp; [&#x27;outboundrtp&#x27;, &#x27;inboundrtp&#x27;].indexOf(streamObj.type) &gt; -1) {
                if (!self._peerStats[peerId][subprop]) {
                  self._peerStats[peerId][subprop] = streamObj;
                }

                result[mediaType][dirType].ssrc = parseInt(streamObj.ssrc || &#x27;0&#x27;, 10);
                result[mediaType][dirType].nacks = self._parseConnectionStats(self._peerStats[peerId][subprop],
                  streamObj, &#x27;nackCount&#x27;);
                result[mediaType][dirType].totalNacks = streamObj.nackCount;

                if (mediaType === &#x27;video&#x27;) {
                  result[mediaType][dirType].firs = self._parseConnectionStats(self._peerStats[peerId][subprop],
                    streamObj, &#x27;firCount&#x27;);
                  result[mediaType][dirType].plis = self._parseConnectionStats(self._peerStats[peerId][subprop],
                    streamObj, &#x27;pliCount&#x27;);
                  result[mediaType][dirType].slis = self._parseConnectionStats(self._peerStats[peerId][subprop],
                    streamObj, &#x27;sliCount&#x27;);
                  result[mediaType][dirType].totalFirs = streamObj.firCount;
                  result[mediaType][dirType].totalPlis = streamObj.plisCount;
                  result[mediaType][dirType].totalSlis = streamObj.sliCount;
                }

                result[mediaType][dirType].bytes = self._parseConnectionStats(self._peerStats[peerId][subprop],
                  streamObj, dirType === &#x27;receiving&#x27; ? &#x27;bytesReceived&#x27; : &#x27;bytesSent&#x27;);
                result[mediaType][dirType].packets = self._parseConnectionStats(self._peerStats[peerId][subprop],
                  streamObj, dirType === &#x27;receiving&#x27; ? &#x27;packetsReceived&#x27; : &#x27;packetsSent&#x27;);

                result[mediaType][dirType].totalBytes = dirType === &#x27;receiving&#x27; ? streamObj.bytesReceived : streamObj.bytesSent;
                result[mediaType][dirType].totalPackets = dirType === &#x27;receiving&#x27; ? streamObj.packetsReceived : streamObj.packetsSent;

                if (dirType === &#x27;receiving&#x27;) {
                  result[mediaType][dirType].jitter = streamObj.jitter || 0;
                  result[mediaType].receiving.fractionLost = streamObj.fractionLost;
                  result[mediaType][dirType].packetsLost = self._parseConnectionStats(self._peerStats[peerId][subprop],
                    streamObj, &#x27;packetsLost&#x27;);
                  result[mediaType][dirType].packetsDiscarded = self._parseConnectionStats(self._peerStats[peerId][subprop],
                    streamObj, &#x27;packetsDiscarded&#x27;);
                  result[mediaType][dirType].totalPacketsLost = streamObj.packetsLost;
                  result[mediaType][dirType].totalPacketsDiscarded = streamObj.packetsDiscarded || 0;
                } else {
                  result[mediaType].sending.rtt = streamObj.roundTripTime || 0;
                  result[mediaType].sending.targetBitrate = streamObj.targetBitrate || 0;
                }

                if (result[mediaType][dirType].codec &amp;&amp; streamObj.codecId) {
                  result[mediaType][dirType].codec.name = streamObj.codecId;
                }
              }
            });
          }
        });
      });

    } else {
      var reportedCandidate = false;
      var reportedCertificate = false;

      loopFn(stats, function (obj, prop) {
        if (prop.indexOf(&#x27;ssrc_&#x27;) === 0) {
          var dirType = prop.indexOf(&#x27;_recv&#x27;) &gt; 0 ? &#x27;receiving&#x27; : &#x27;sending&#x27;;

          // Polyfill fix for plugin. Plugin should fix this though
          if (!obj.mediaType) {
            obj.mediaType = obj.hasOwnProperty(&#x27;audioOutputLevel&#x27;) || obj.hasOwnProperty(&#x27;audioInputLevel&#x27;) ||
              obj.hasOwnProperty(&#x27;googEchoCancellationReturnLoss&#x27;) || obj.hasOwnProperty(&#x27;googEchoCancellation&#x27;) ?
              &#x27;audio&#x27; : &#x27;video&#x27;;
          }

          if (!self._peerStats[peerId][prop]) {
            self._peerStats[peerId][prop] = obj;
          }

          // Capture e2e delay
          try {
            if (obj.mediaType === &#x27;video&#x27; &amp;&amp; dirType === &#x27;receiving&#x27;) {
              var captureStartNtpTimeMs = parseInt(obj.googCaptureStartNtpTimeMs || &#x27;0&#x27;, 10);

              if (captureStartNtpTimeMs &gt; 0 &amp;&amp; pc.getRemoteStreams().length &gt; 0 &amp;&amp; document &amp;&amp;
                typeof document.getElementsByTagName === &#x27;function&#x27;) {
                var streamId = pc.getRemoteStreams()[0].id || pc.getRemoteStreams()[0].label;
                var elements = [];

                if (self._isUsingPlugin) {
                  elements = document.getElementsByTagName(&#x27;object&#x27;);
                } else {
                  elements = document.getElementsByTagName(&#x27;video&#x27;);

                  if (elements.length === 0) {
                    elements = document.getElementsByTagName(&#x27;audio&#x27;);
                  }
                }

                for (var e = 0; e &lt; elements.length; e++) {
                  var videoElmStreamId = null;

                  if (self._isUsingPlugin) {
                    if (!(elements[e].children &amp;&amp; typeof elements[e].children === &#x27;object&#x27; &amp;&amp;
                      typeof elements[e].children.length === &#x27;number&#x27; &amp;&amp; elements[e].children.length &gt; 0)) {
                      break;
                    }

                    for (var ec = 0; ec &lt; elements[e].children.length; ec++) {
                      if (elements[e].children[ec].name === &#x27;streamId&#x27;) {
                        videoElmStreamId = elements[e].children[ec].value || null;
                        break;
                      }
                    }

                  } else {
                    videoElmStreamId = elements[e].srcObject ? elements[e].srcObject.id ||
                      elements[e].srcObject.label : null;
                  }

                  if (videoElmStreamId &amp;&amp; videoElmStreamId === streamId) {
                    result[obj.mediaType][dirType].e2eDelay = ((new Date()).getTime() + 2208988800000) -
                      captureStartNtpTimeMs - elements[e].currentTime * 1000;
                    break;
                  }
                }
              }
            }
          } catch (error) {
            log.warn([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Failed retrieving e2e delay -&gt;&#x27;], error);
          }

          // Receiving/Sending RTP packets
          result[obj.mediaType][dirType].ssrc = parseInt(obj.ssrc || &#x27;0&#x27;, 10);
          result[obj.mediaType][dirType].bytes = self._parseConnectionStats(self._peerStats[peerId][prop],
            obj, dirType === &#x27;receiving&#x27; ? &#x27;bytesReceived&#x27; : &#x27;bytesSent&#x27;);
          result[obj.mediaType][dirType].packets = self._parseConnectionStats(self._peerStats[peerId][prop],
            obj, dirType === &#x27;receiving&#x27; ? &#x27;packetsReceived&#x27; : &#x27;packetsSent&#x27;);
          result[obj.mediaType][dirType].nacks = self._parseConnectionStats(self._peerStats[peerId][prop],
            obj, dirType === &#x27;receiving&#x27; ? &#x27;googNacksReceived&#x27; : &#x27;googNacksSent&#x27;);
          result[obj.mediaType][dirType].totalPackets = parseInt((dirType === &#x27;receiving&#x27; ? obj.packetsReceived :
            obj.packetsSent) || &#x27;0&#x27;, 10);
          result[obj.mediaType][dirType].totalBytes = parseInt((dirType === &#x27;receiving&#x27; ? obj.bytesReceived :
            obj.bytesSent) || &#x27;0&#x27;, 10);
          result[obj.mediaType][dirType].totalNacks = parseInt((dirType === &#x27;receiving&#x27; ? obj.googNacksReceived :
            obj.googNacksSent) || &#x27;0&#x27;, 10);

          if (result[obj.mediaType][dirType].codec) {
            if (obj.googCodecName &amp;&amp; obj.googCodecName !== &#x27;unknown&#x27;) {
              result[obj.mediaType][dirType].codec.name = obj.googCodecName;
            }
            if (obj.codecImplementationName &amp;&amp; obj.codecImplementationName !== &#x27;unknown&#x27;) {
              result[obj.mediaType][dirType].codec.implementation = obj.codecImplementationName;
            }
          }

          if (dirType === &#x27;sending&#x27;) {
            // NOTE: Chrome sending audio does have it but plugin has..
            result[obj.mediaType].sending.rtt = parseFloat(obj.googRtt || &#x27;0&#x27;, 10);
            result[obj.mediaType].sending.targetBitrate = obj.targetBitrate ? parseInt(obj.targetBitrate, 10) : null;
          } else {
            result[obj.mediaType].receiving.packetsLost = self._parseConnectionStats(self._peerStats[peerId][prop],
              obj, &#x27;packetsLost&#x27;);
            result[obj.mediaType].receiving.packetsDiscarded = self._parseConnectionStats(self._peerStats[peerId][prop],
              obj, &#x27;packetsDiscarded&#x27;);
            result[obj.mediaType].receiving.jitter = parseFloat(obj.googJitterReceived || &#x27;0&#x27;, 10);
            result[obj.mediaType].receiving.jitterBufferMs = obj.googJitterBufferMs ? parseFloat(obj.googJitterBufferMs || &#x27;0&#x27;, 10) : null;
            result[obj.mediaType].receiving.totalPacketsLost = parseInt(obj.packetsLost || &#x27;0&#x27;, 10);
            result[obj.mediaType].receiving.totalPacketsDiscarded = parseInt(obj.packetsDiscarded || &#x27;0&#x27;, 10);
          }

          if (obj.mediaType === &#x27;video&#x27;) {
            result.video[dirType].framesCorrupted = obj.framesCorrupted ? parseInt(obj.framesCorrupted, 10) : null;
            result.video[dirType].framesPerSecond = obj.framesPerSecond ? parseFloat(obj.framesPerSecond, 10) : null;
            result.video[dirType].framesDropped = obj.framesDropped ? parseInt(obj.framesDropped, 10) : null;
            
            if (dirType === &#x27;sending&#x27;) {
              result.video[dirType].frameWidth = obj.googFrameWidthSent ?
                parseInt(obj.googFrameWidthSent, 10) : null;
              result.video[dirType].frameHeight = obj.googFrameHeightSent ?
                parseInt(obj.googFrameHeightSent, 10) : null;
              result.video[dirType].plis = obj.googPlisSent ?
                self._parseConnectionStats(self._peerStats[peerId][prop], obj, &#x27;googPlisSent&#x27;) : null;
              result.video[dirType].firs = obj.googFirsSent ?
                self._parseConnectionStats(self._peerStats[peerId][prop], obj, &#x27;googFirsSent&#x27;) : null;
              result[obj.mediaType][dirType].totalPlis = obj.googPlisSent ? parseInt(obj.googPlisSent, 10) : null;
              result[obj.mediaType][dirType].totalFirs = obj.googFirsSent ? parseInt(obj.googFirsSent, 10) : null;
              result.video[dirType].framesEncoded = obj.framesEncoded ? parseInt(obj.framesEncoded, 10) : null;
              result.video[dirType].frameRateEncoded = obj.googFrameRateEncoded ?
                parseInt(obj.googFrameRateEncoded, 10) : null;
              result.video[dirType].frameRateInput = obj.googFrameRateInput ?
                parseInt(obj.googFrameRateInput, 10) : null;
              result.video[dirType].frameRate = obj.googFrameRateSent ?
                parseInt(obj.googFrameRateSent, 10) : null;
              result.video[dirType].qpSum = obj.qpSum ? parseInt(obj.qpSum, 10) : null;
              result.video[dirType].frames = obj.framesSent ?
                self._parseConnectionStats(self._peerStats[peerId][prop], obj, &#x27;framesSent&#x27;) : null;
              result.video[dirType].totalFrames = obj.framesSent ? parseInt(obj.framesSent, 10) : null;
            } else {
              result.video[dirType].frameWidth = obj.googFrameWidthReceived ?
                parseInt(obj.googFrameWidthReceived, 10) : null;
              result.video[dirType].frameHeight = obj.googFrameHeightReceived ?
                parseInt(obj.googFrameHeightReceived, 10) : null;
              result.video[dirType].plis = obj.googPlisReceived ?
                self._parseConnectionStats(self._peerStats[peerId][prop], obj, &#x27;googPlisReceived&#x27;) : null;
              result.video[dirType].firs = obj.googFirsReceived ?
                self._parseConnectionStats(self._peerStats[peerId][prop], obj, &#x27;googFirsReceived&#x27;) : null;
              result[obj.mediaType][dirType].totalPlis = obj.googPlisReceived ? parseInt(obj.googPlisReceived, 10) : null;
              result[obj.mediaType][dirType].totalFirs = obj.googFirsReceived ? parseInt(obj.googFirsReceived, 10) : null;
              result.video[dirType].framesDecoded = obj.framesDecoded ? parseInt(obj.framesDecoded, 10) : null;
              result.video[dirType].frameRateDecoded = obj.googFrameRateDecoded ?
                parseInt(obj.googFrameRateDecoded, 10) : null;
              result.video[dirType].frameRateOutput = obj.googFrameRateOutput ?
                parseInt(obj.googFrameRateOutput, 10) : null;
              result.video[dirType].frameRate = obj.googFrameRateReceived ?
                parseInt(obj.googFrameRateReceived, 10) : null;
              result.video[dirType].frames = obj.framesReceived ?
                self._parseConnectionStats(self._peerStats[peerId][prop], obj, &#x27;framesReceived&#x27;) : null;
              result.video[dirType].totalFrames = obj.framesReceived ? parseInt(obj.framesReceived, 10) : null;
            }
          } else {
            if (dirType === &#x27;receiving&#x27;) {
              result.audio[dirType].outputLevel = parseFloat(obj.audioOutputLevel || &#x27;0&#x27;, 10);
            } else {
              result.audio[dirType].inputLevel = parseFloat(obj.audioInputLevel || &#x27;0&#x27;, 10);
              result.audio[dirType].echoReturnLoss = parseFloat(obj.googEchoCancellationReturnLoss || &#x27;0&#x27;, 10);
              result.audio[dirType].echoReturnLossEnhancement = parseFloat(obj.googEchoCancellationReturnLossEnhancement || &#x27;0&#x27;, 10);
            }
          }

          self._peerStats[peerId][prop] = obj;

          if (!reportedCandidate) {
            loopFn(stats, function (canObj, canProp) {
              if (!reportedCandidate &amp;&amp; canProp.indexOf(&#x27;Conn-&#x27;) === 0) {
                if (obj.transportId === canObj.googChannelId) {
                  if (!self._peerStats[peerId][canProp]) {
                    self._peerStats[peerId][canProp] = canObj;
                  }
                  formatCandidateFn(&#x27;local&#x27;, stats[canObj.localCandidateId]);
                  formatCandidateFn(&#x27;remote&#x27;, stats[canObj.remoteCandidateId]);
                  result.selectedCandidate.writable = canObj.googWritable ? canObj.googWritable === &#x27;true&#x27; : null;
                  result.selectedCandidate.readable = canObj.googReadable ? canObj.googReadable === &#x27;true&#x27; : null;
                  result.selectedCandidate.rtt = canObj.googRtt ?
                    self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;googRtt&#x27;) : null;
                  result.selectedCandidate.totalRtt = canObj.googRtt ? parseInt(canObj.googRtt, 10) : null;
                  result.selectedCandidate.requests = {
                    received: canObj.requestsReceived ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;requestsReceived&#x27;) : null,
                    sent: canObj.requestsSent ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;requestsSent&#x27;) : null,
                    totalReceived: canObj.requestsReceived ? parseInt(canObj.requestsReceived, 10) : null,
                    totalSent: canObj.requestsSent ? parseInt(canObj.requestsSent, 10) : null
                  };
                  result.selectedCandidate.responses = {
                    received: canObj.responsesReceived ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;responsesReceived&#x27;) : null,
                    sent: canObj.responsesSent ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;responsesSent&#x27;) : null,
                    totalReceived: canObj.responsesReceived ? parseInt(canObj.responsesReceived, 10) : null,
                    totalSent: canObj.responsesSent ? parseInt(canObj.responsesSent, 10) : null
                  };
                  result.selectedCandidate.consentRequests = {
                    received: canObj.consentRequestsReceived ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;consentRequestsReceived&#x27;) : null,
                    sent: canObj.consentRequestsSent ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;consentRequestsSent&#x27;) : null,
                    totalReceived: canObj.consentRequestsReceived ? parseInt(canObj.consentRequestsReceived, 10) : null,
                    totalSent: canObj.consentRequestsSent ? parseInt(canObj.consentRequestsSent, 10) : null
                  };
                  result.selectedCandidate.consentResponses = {
                    received: canObj.consentResponsesReceived ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;consentResponsesReceived&#x27;) : null,
                    sent: canObj.consentResponsesSent ?
                      self._parseConnectionStats(self._peerStats[peerId][canProp], canObj, &#x27;consentResponsesSent&#x27;) : null,
                    totalReceived: canObj.consentResponsesReceived ? parseInt(canObj.consentResponsesReceived, 10) : null,
                    totalSent: canObj.consentResponsesSent ? parseInt(canObj.consentResponsesSent, 10) : null
                  };
  
                  self._peerStats[peerId][canProp] = canObj;
                  reportedCandidate = true;
                }
              }
            });
          }

          if (!reportedCertificate &amp;&amp; stats[obj.transportId]) {
            result.certificate.srtpCipher = stats[obj.transportId].srtpCipher || null;
            result.certificate.dtlsCipher = stats[obj.transportId].dtlsCipher || null;

            var localCertId = stats[obj.transportId].localCertificateId;
            var remoteCertId = stats[obj.transportId].remoteCertificateId;

            if (localCertId &amp;&amp; stats[localCertId]) {
              result.certificate.local.derBase64 = stats[localCertId].googDerBase64 || null;
              if (stats[localCertId].googFingerprint) {
                result.certificate.local.fingerprint = stats[localCertId].googFingerprint;
              }
              if (stats[localCertId].googFingerprintAlgorithm) {
                result.certificate.local.fingerprintAlgorithm = stats[localCertId].googFingerprintAlgorithm;
              }
            }

            if (remoteCertId &amp;&amp; stats[remoteCertId]) {
              result.certificate.remote.derBase64 = stats[remoteCertId].googDerBase64 || null;
              if (stats[remoteCertId].googFingerprint) {
                result.certificate.remote.fingerprint = stats[remoteCertId].googFingerprint;
              }
              if (stats[remoteCertId].googFingerprintAlgorithm) {
                result.certificate.remote.fingerprintAlgorithm = stats[remoteCertId].googFingerprintAlgorithm;
              }
            }
            reportedCertificate = true;
          }
        }
      });
    }

    if ((result.selectedCandidate.local.candidateType || &#x27;&#x27;).indexOf(&#x27;relay&#x27;) === 0) {
      result.selectedCandidate.local.turnMediaTransport = &#x27;UDP&#x27;;
      if (self._forceTURNSSL &amp;&amp; window.webrtcDetectedBrowser !== &#x27;firefox&#x27;) {
        result.selectedCandidate.local.turnMediaTransport = &#x27;TCP/TLS&#x27;;
      } else if ((self._options.TURNServerTransport === self.TURN_TRANSPORT.TCP || self._options.forceTURNSSL) &amp;&amp;
        self._user.iceServers.length &gt; 0 &amp;&amp; self._user.iceServers[0] &amp;&amp; self._user.iceServers[0].urls[0] &amp;&amp;
        self._user.iceServers[0].urls[0].indexOf(&#x27;?transport=tcp&#x27;) &gt; 0) {
        result.selectedCandidate.local.turnMediaTransport = &#x27;TCP&#x27;;
      }
    } else {
      result.selectedCandidate.local.turnMediaTransport = null;
    }

    callback(null, result);

  }, function (error) {
    callback(error, null);
  });
};

/**
 * Function that starts the Peer connection session.
 * Remember to remove previous method of reconnection (re-creating the Peer connection - destroy and create connection).
 * @method _addPeer
 * @private
 * @for Skylink
 * @since 0.5.4
 */
Skylink.prototype._addPeer = function(targetMid, peerBrowser, toOffer, restartConn, receiveOnly, isSS) {
  var self = this;
  if (self._peerConnections[targetMid] &amp;&amp; !restartConn) {
    log.error([targetMid, null, null, &#x27;Connection to peer has already been made&#x27;]);
    return;
  }
  log.log([targetMid, null, null, &#x27;Starting the connection to peer. Options provided:&#x27;], {
    peerBrowser: peerBrowser,
    toOffer: toOffer,
    receiveOnly: receiveOnly,
    enableDataChannel: self._options.enableDataChannel
  });

  log.info(&#x27;Adding peer&#x27;, isSS);

  if (!restartConn) {
    self._peerConnections[targetMid] = self._createPeerConnection(targetMid, !!isSS);
  }

  if (!self._peerConnections[targetMid]) {
    log.error([targetMid, null, null, &#x27;Failed creating the connection to peer&#x27;]);
    return;
  }

  self._peerConnections[targetMid].hasScreen = !!isSS;
};

/**
 * Function that re-negotiates a Peer connection.
 * Remember to remove previous method of reconnection (re-creating the Peer connection - destroy and create connection).
 * @method _restartPeerConnection
 * @private
 * @for Skylink
 * @since 0.5.8
 */
Skylink.prototype._restartPeerConnection = function (peerId, doIceRestart, callback) {
  var self = this;

  if (!self._peerConnections[peerId]) {
    log.error([peerId, null, null, &#x27;Peer does not have an existing &#x27; +
      &#x27;connection. Unable to restart&#x27;]);
    return;
  }

  var pc = self._peerConnections[peerId];
  var agent = (self.getPeerInfo(peerId) || {}).agent || {};

  // prevent restarts for other SDK clients
  if (self._isLowerThanVersion(agent.SMProtocolVersion || &#x27;&#x27;, &#x27;0.1.2&#x27;)) {
    var notSupportedError = new Error(&#x27;Failed restarting with other agents connecting from other SDKs as &#x27; +
      &#x27;re-negotiation is not supported by other SDKs&#x27;);

    log.warn([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Ignoring restart request as agent\&#x27;s SDK does not support it&#x27;],
        notSupportedError);

    if (typeof callback === &#x27;function&#x27;) {
      log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart failure callback&#x27;]);
      callback(notSupportedError);
    }
    return;
  }

  // This is when the state is stable and re-handshaking is possible
  // This could be due to previous connection handshaking that is already done
  if (pc.signalingState === self.PEER_CONNECTION_STATE.STABLE &amp;&amp; self._peerConnections[peerId]) {
    log.log([peerId, null, null, &#x27;Sending restart message to signaling server&#x27;]);

    var restartMsg = {
      type: self._SIG_MESSAGE_TYPE.RESTART,
      mid: self._user.id,
      rid: self._user.room.session.rid,
      agent: window.webrtcDetectedBrowser,
      version: (window.webrtcDetectedVersion || 0).toString(),
      os: window.navigator.platform,
      userInfo: self._getUserInfo(),
      target: peerId,
      weight: self._user.priorityWeight,
      receiveOnly: self.getPeerInfo().config.receiveOnly,
      enableIceTrickle: self._options.enableIceTrickle,
      enableDataChannel: self._options.enableDataChannel,
      enableIceRestart: self._enableIceRestart,
      doIceRestart: doIceRestart === true &amp;&amp; self._enableIceRestart &amp;&amp; self._peerInformations[peerId] &amp;&amp;
        self._peerInformations[peerId].config.enableIceRestart,
      isRestartResend: false,
      temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,
      SMProtocolVersion: self.SM_PROTOCOL_VERSION,
      DTProtocolVersion: self.DT_PROTOCOL_VERSION
    };

    if (self._user.connection.publishOnly) {
      restartMsg.publishOnly = {
        type: self._streams.screenshare &amp;&amp; self._streams.screenshare.stream ? &#x27;screenshare&#x27; : &#x27;video&#x27;
      };
    }

    if (self._user.parentId) {
      restartMsg.parentId = self._user.parentId;
    }

    self._peerEndOfCandidatesCounter[peerId] = self._peerEndOfCandidatesCounter[peerId] || {};
    self._peerEndOfCandidatesCounter[peerId].len = 0;
    self._socketSendMessage(restartMsg);
    self._trigger(&#x27;peerRestart&#x27;, peerId, self.getPeerInfo(peerId), true, doIceRestart === true);

    if (typeof callback === &#x27;function&#x27;) {
      log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart callback&#x27;]);
      callback(null);
    }

  } else {
    // Let&#x27;s check if the signalingState is stable first.
    // In another galaxy or universe, where the local description gets dropped..
    // In the offerHandler or answerHandler, do the appropriate flags to ignore or drop &quot;extra&quot; descriptions
    if (pc.signalingState === self.PEER_CONNECTION_STATE.HAVE_LOCAL_OFFER) {
      // Checks if the local description is defined first
      var hasLocalDescription = pc.localDescription &amp;&amp; pc.localDescription.sdp;
      // By then it should have at least the local description..
      if (hasLocalDescription) {
        self._socketSendMessage({
          type: pc.localDescription.type,
          sdp: pc.localDescription.sdp,
          mid: self._user.id,
          target: peerId,
          rid: self._user.room.session.rid,
          restart: true
        });
      } else {
        var noLocalDescriptionError = &#x27;Failed re-sending localDescription as there is &#x27; +
          &#x27;no localDescription set to connection. There could be a handshaking step error&#x27;;
        log.error([peerId, &#x27;RTCPeerConnection&#x27;, null, noLocalDescriptionError], {
            localDescription: pc.localDescription,
            remoteDescription: pc.remoteDescription
        });
        if (typeof callback === &#x27;function&#x27;) {
          log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart failure callback&#x27;]);
          callback(new Error(noLocalDescriptionError));
        }
      }
    // It could have connection state closed
    } else {
      var unableToRestartError = &#x27;Failed restarting as peer connection state is &#x27; + pc.signalingState;
      log.warn([peerId, &#x27;RTCPeerConnection&#x27;, null, unableToRestartError]);
      if (typeof callback === &#x27;function&#x27;) {
        log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart failure callback&#x27;]);
        callback(new Error(unableToRestartError));
      }
    }
  }
};

/**
 * Function that ends the Peer connection session.
 * @method _removePeer
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._removePeer = function(peerId) {
  if (!this._peerConnections[peerId] &amp;&amp; !this._peerInformations[peerId]) {
    log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Dropping the hangup from Peer as not connected to Peer at all.&#x27;]);
    return;
  }

  var peerInfo = clone(this.getPeerInfo(peerId)) || {
    userData: &#x27;&#x27;,
    settings: {},
    mediaStatus: {},
    agent: {},
    config: {},
    room: clone(this._selectedRoom)
  };

  if (peerId !== &#x27;MCU&#x27;) {
    this._trigger(&#x27;peerLeft&#x27;, peerId, peerInfo, false);
  } else {
    this._hasMCU = false;
    log.log([peerId, null, null, &#x27;MCU has stopped listening and left&#x27;]);
    this._trigger(&#x27;serverPeerLeft&#x27;, peerId, this.SERVER_PEER_TYPE.MCU);
  }

  // check if health timer exists
  if (this._peerConnections[peerId]) {
    if (this._peerConnections[peerId].signalingState !== this.PEER_CONNECTION_STATE.CLOSED) {
      this._peerConnections[peerId].close();
    }

    if (peerId !== &#x27;MCU&#x27;) {
      this._handleEndedStreams(peerId);
    }

    delete this._peerConnections[peerId];
  }
  // remove peer informations session
  if (this._peerInformations[peerId]) {
    delete this._peerInformations[peerId];
  }
  // remove peer messages stamps session
  if (this._peerMessagesStamps[peerId]) {
    delete this._peerMessagesStamps[peerId];
  }
  // remove peer streams session
  if (this._streamsSession[peerId]) {
    delete this._streamsSession[peerId];
  }
  // remove peer streams session
  if (this._peerEndOfCandidatesCounter[peerId]) {
    delete this._peerEndOfCandidatesCounter[peerId];
  }
  // remove peer sdp session
  if (this._sdpSessions[peerId]) {
    delete this._sdpSessions[peerId];
  }

  // close datachannel connection
  if (this._dataChannels[peerId]) {
    this._closeDataChannel(peerId);
  }

  log.log([peerId, null, null, &#x27;Successfully removed peer&#x27;]);
};

/**
 * Function that creates the Peer connection.
 * @method _createPeerConnection
 * @private
 * @for Skylink
 * @since 0.5.1
 */
Skylink.prototype._createPeerConnection = function(targetMid, isScreenSharing) {
  var pc, self = this;
  if (!self._user.room.connected || !Array.isArray(self._user.iceServers)) {
    return;
  }
  // currently the AdapterJS 0.12.1-2 causes an issue to prevent firefox from
  // using .urls feature
  try {
    pc = new RTCPeerConnection({
      iceServers: self._user.iceServers,
      iceTransportPolicy: self._options.filterCandidatesType.host &amp;&amp; self._options.filterCandidatesType.srflx &amp;&amp;
        !self._options.filterCandidatesType.relay ? &#x27;relay&#x27; : &#x27;all&#x27;,
      bundlePolicy: &#x27;max-bundle&#x27;,
      rtcpMuxPolicy: &#x27;require&#x27;
    }, {
      optional: [
        { DtlsSrtpKeyAgreement: true },
        { googIPv6: true }
      ]
    });
    log.info([targetMid, null, null, &#x27;Created peer connection&#x27;]);
  } catch (error) {
    log.error([targetMid, null, null, &#x27;Failed creating peer connection:&#x27;], error);
    return null;
  }
  // attributes (added on by Temasys)
  pc.setOffer = &#x27;&#x27;;
  pc.setAnswer = &#x27;&#x27;;
  pc.hasStream = false;
  pc.hasScreen = !!isScreenSharing;
  pc.hasMainChannel = false;
  pc.firefoxStreamId = &#x27;&#x27;;
  pc.processingLocalSDP = false;
  pc.processingRemoteSDP = false;
  pc.gathered = false;
  pc.gathering = false;

  // candidates
  self._gatheredCandidates[targetMid] = {
    sending: { host: [], srflx: [], relay: [] },
    receiving: { host: [], srflx: [], relay: [] }
  };

  self._streamsSession[targetMid] = self._streamsSession[targetMid] || {};
  self._peerEndOfCandidatesCounter[targetMid] = self._peerEndOfCandidatesCounter[targetMid] || {};
  self._sdpSessions[targetMid] = { local: {}, remote: {} };

  // callbacks
  // standard not implemented: onnegotiationneeded,
  pc.ondatachannel = function(event) {
    var dc = event.channel || event;
    log.debug([targetMid, &#x27;RTCDataChannel&#x27;, dc.label, &#x27;Received datachannel -&gt;&#x27;], dc);
    if (self._options.enableDataChannel &amp;&amp; self._peerInformations[targetMid] &amp;&amp;
      self._peerInformations[targetMid].config.enableDataChannel) {
      var channelType = self.DATA_CHANNEL_TYPE.DATA;
      var channelKey = dc.label;

      // if peer does not have main channel, the first item is main
      if (!pc.hasMainChannel) {
        channelType = self.DATA_CHANNEL_TYPE.MESSAGING;
        channelKey = &#x27;main&#x27;;
        pc.hasMainChannel = true;
      }

      self._createDataChannel(targetMid, dc);

    } else {
      log.warn([targetMid, &#x27;RTCDataChannel&#x27;, dc.label, &#x27;Not adding datachannel as enable datachannel &#x27; +
        &#x27;is set to false&#x27;]);
    }
  };

  pc.onaddstream = function(event) {
    if (!self._peerConnections[targetMid]) {
      return;
    }

    var stream = event.stream || event;
    var streamId = stream.id || stream.label;

    if (targetMid === &#x27;MCU&#x27;) {
      log.warn([targetMid, &#x27;MediaStream&#x27;, streamId, &#x27;Ignoring received remote stream from MCU -&gt;&#x27;], stream);
      return;
    } else if (!self._sdpSettings.direction.audio.receive &amp;&amp; !self._sdpSettings.direction.video.receive) {
      log.warn([targetMid, &#x27;MediaStream&#x27;, streamId, &#x27;Ignoring received empty remote stream -&gt;&#x27;], stream);
      return;
    }

    // Fixes for the dirty-hack for Chrome offer to Firefox (inactive)
    // See: ESS-680
    if (!self._hasMCU &amp;&amp; window.webrtcDetectedBrowser === &#x27;firefox&#x27; &amp;&amp;
      pc.getRemoteStreams().length &gt; 1 &amp;&amp; pc.remoteDescription &amp;&amp; pc.remoteDescription.sdp) {

      if (pc.remoteDescription.sdp.indexOf(&#x27; msid:&#x27; + streamId + &#x27; &#x27;) === -1) {
        log.warn([targetMid, &#x27;MediaStream&#x27;, streamId, &#x27;Ignoring received empty remote stream -&gt;&#x27;], stream);
        return;
      }
    }

    var peerSettings = clone(self.getPeerInfo(targetMid).settings);
    var hasScreenshare = peerSettings.video &amp;&amp; typeof peerSettings.video === &#x27;object&#x27; &amp;&amp; !!peerSettings.video.screenshare;

    pc.hasStream = true;
    pc.hasScreen = !!hasScreenshare;

    self._streamsSession[targetMid][streamId] = peerSettings;
    self._onRemoteStreamAdded(targetMid, stream, !!hasScreenshare);
  };

  pc.onicecandidate = function(event) {
    self._onIceCandidate(targetMid, event.candidate || event);
  };

  pc.oniceconnectionstatechange = function(evt) {
    var iceConnectionState = pc.iceConnectionState;

    log.debug([targetMid, &#x27;RTCIceConnectionState&#x27;, null, &#x27;Ice connection state changed -&gt;&#x27;], iceConnectionState);

    if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
      if (iceConnectionState === &#x27;connecting&#x27;) {
        iceConnectionState = self.ICE_CONNECTION_STATE.CHECKING;
      } else if (iceConnectionState === &#x27;new&#x27;) {
        iceConnectionState = self.ICE_CONNECTION_STATE.FAILED;
      }
    }

    self._trigger(&#x27;iceConnectionState&#x27;, iceConnectionState, targetMid);

    if (pc.iceConnectionState === self.ICE_CONNECTION_STATE.FAILED &amp;&amp; self._options.enableIceTrickle) {
      self._trigger(&#x27;iceConnectionState&#x27;, self.ICE_CONNECTION_STATE.TRICKLE_FAILED, targetMid);
    }
  };

  pc.onsignalingstatechange = function() {
    log.debug([targetMid, &#x27;RTCSignalingState&#x27;, null, &#x27;Peer connection state changed -&gt;&#x27;], pc.signalingState);
    self._trigger(&#x27;peerConnectionState&#x27;, pc.signalingState, targetMid);
  };
  pc.onicegatheringstatechange = function() {
    log.log([targetMid, &#x27;RTCIceGatheringState&#x27;, null, &#x27;Ice gathering state changed -&gt;&#x27;], pc.iceGatheringState);
    self._trigger(&#x27;candidateGenerationState&#x27;, pc.iceGatheringState, targetMid);
  };

  if (window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
    pc.removeStream = function (stream) {
      var senders = pc.getSenders();
      for (var s = 0; s &lt; senders.length; s++) {
        var tracks = stream.getTracks();
        for (var t = 0; t &lt; tracks.length; t++) {
          if (tracks[t] === senders[s].track) {
            pc.removeTrack(senders[s]);
          }
        }
      }
    };
  }

  return pc;
};

/**
 * Function that handles the &lt;code&gt;_restartPeerConnection&lt;/code&gt; scenario
 *   for MCU enabled Peer connections.
 * This is implemented currently by making the user leave and join the Room again.
 * The Peer ID will not stay the same though.
 * @method _restartMCUConnection
 * @private
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._restartMCUConnection = function(callback, doIceRestart) {
  var self = this;
  var listOfPeers = Object.keys(self._peerConnections);
  var listOfPeerRestartErrors = {};
  var sendRestartMsgFn = function (peerId) {
    var restartMsg = {
      type: self._SIG_MESSAGE_TYPE.RESTART,
      mid: self._user.id,
      rid: self._user.room.session.rid,
      agent: window.webrtcDetectedBrowser,
      version: (window.webrtcDetectedVersion || 0).toString(),
      os: window.navigator.platform,
      userInfo: self._getUserInfo(),
      target: peerId,
      weight: self._user.priorityWeight,
      receiveOnly: self.getPeerInfo().config.receiveOnly,
      enableIceTrickle: self._options.enableIceTrickle,
      enableDataChannel: self._options.enableDataChannel,
      enableIceRestart: self._enableIceRestart,
      doIceRestart: self._options.mcuUseRenegoRestart &amp;&amp; doIceRestart === true &amp;&amp;
        self._enableIceRestart &amp;&amp; self._peerInformations[peerId] &amp;&amp;
        self._peerInformations[peerId].config.enableIceRestart,
      isRestartResend: false,
      temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,
      SMProtocolVersion: self.SM_PROTOCOL_VERSION,
      DTProtocolVersion: self.DT_PROTOCOL_VERSION
    };

    if (self._user.connection.publishOnly) {
      restartMsg.publishOnly = {
        type: self._streams.screenshare &amp;&amp; self._streams.screenshare.stream ? &#x27;screenshare&#x27; : &#x27;video&#x27;
      };
    }

    if (self._user.parentId) {
      restartMsg.parentId = self._user.parentId;
    }

    log.log([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Sending restart message to signaling server -&gt;&#x27;], restartMsg);

    self._socketSendMessage(restartMsg);
  };

  for (var i = 0; i &lt; listOfPeers.length; i++) {
    if (!self._peerConnections[listOfPeers[i]]) {
      var error = &#x27;Peer connection with peer does not exists. Unable to restart&#x27;;
      log.error([listOfPeers[i], &#x27;PeerConnection&#x27;, null, error]);
      listOfPeerRestartErrors[listOfPeers[i]] = new Error(error);
      continue;
    }

    if (listOfPeers[i] !== &#x27;MCU&#x27;) {
      self._trigger(&#x27;peerRestart&#x27;, listOfPeers[i], self.getPeerInfo(listOfPeers[i]), true, false);

      if (!self._mcuUseRenegoRestart) {
        sendRestartMsgFn(listOfPeers[i]);
      }
    }
  }

  self._trigger(&#x27;serverPeerRestart&#x27;, &#x27;MCU&#x27;, self.SERVER_PEER_TYPE.MCU);

  if (self._mcuUseRenegoRestart) {
    self._peerEndOfCandidatesCounter.MCU = self._peerEndOfCandidatesCounter.MCU || {};
    self._peerEndOfCandidatesCounter.MCU.len = 0;
    sendRestartMsgFn(&#x27;MCU&#x27;);
  } else {
    // Restart with MCU = peer leaves then rejoins room
    var peerJoinedFn = function (peerId, peerInfo, isSelf) {
      log.log([null, &#x27;PeerConnection&#x27;, null, &#x27;Invoked all peers to restart with MCU. Firing callback&#x27;]);

      if (typeof callback === &#x27;function&#x27;) {
        if (Object.keys(listOfPeerRestartErrors).length &gt; 0) {
          callback({
            refreshErrors: listOfPeerRestartErrors,
            listOfPeers: listOfPeers
          }, null);
        } else {
          callback(null, {
            listOfPeers: listOfPeers
          });
        }
      }
    };

    self.once(&#x27;peerJoined&#x27;, peerJoinedFn, function (peerId, peerInfo, isSelf) {
      return isSelf;
    });

    self.leaveRoom(false, function (error, success) {
      if (error) {
        if (typeof callback === &#x27;function&#x27;) {
          for (var i = 0; i &lt; listOfPeers.length; i++) {
            listOfPeerRestartErrors[listOfPeers[i]] = error;
          }
          callback({
            refreshErrors: listOfPeerRestartErrors,
            listOfPeers: listOfPeers
          }, null);
        }
      } else {
        //self._trigger(&#x27;serverPeerLeft&#x27;, &#x27;MCU&#x27;, self.SERVER_PEER_TYPE.MCU);
        self.joinRoom(self._selectedRoom);
      }
    });
  }
};

/**
 * Function that handles the stats tabulation.
 * @method _parseConnectionStats
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._parseConnectionStats = function(prevStats, stats, prop) {
  var nTime = stats.timestamp;
  var oTime = prevStats.timestamp;
  var nVal = parseFloat(stats[prop] || &#x27;0&#x27;, 10);
  var oVal = parseFloat(prevStats[prop] || &#x27;0&#x27;, 10);

  if ((new Date(nTime).getTime()) === (new Date(oTime).getTime())) {
    return nVal;
  }

  return parseFloat(((nVal - oVal) / (nTime - oTime) * 1000).toFixed(3) || &#x27;0&#x27;, 10);
};

/**
 * Function that signals the end-of-candidates flag.
 * @method _signalingEndOfCandidates
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._signalingEndOfCandidates = function(targetMid) {
  var self = this;

  if (!self._peerEndOfCandidatesCounter[targetMid]) {
    return;
  }

  // If remote description is set
  if (self._peerConnections[targetMid].remoteDescription &amp;&amp; self._peerConnections[targetMid].remoteDescription.sdp &amp;&amp;
  // If end-of-candidates signal is received
    typeof self._peerEndOfCandidatesCounter[targetMid].expectedLen === &#x27;number&#x27; &amp;&amp;
  // If all ICE candidates are received
    self._peerEndOfCandidatesCounter[targetMid].len &gt;= self._peerEndOfCandidatesCounter[targetMid].expectedLen &amp;&amp;
  // If there is no ICE candidates queue
    (self._peerCandidatesQueue[targetMid] ? self._peerCandidatesQueue[targetMid].length === 0 : true) &amp;&amp;
  // If it has not been set yet
    !self._peerEndOfCandidatesCounter[targetMid].hasSet) {
    log.debug([targetMid, &#x27;RTCPeerConnection&#x27;, null, &#x27;Signaling of end-of-candidates remote ICE gathering.&#x27;]);
    self._peerEndOfCandidatesCounter[targetMid].hasSet = true;
    try {
      if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
        var mLineCounter = -1;
        var addedMids = [];
        var sdpLines = self._peerConnections[targetMid].remoteDescription.sdp.split(&#x27;\r\n&#x27;);

        for (var i = 0; i &lt; sdpLines.length; i++) {
          if (sdpLines[i].indexOf(&#x27;m=&#x27;) === 0) {
            mLineCounter++;
          } else if (sdpLines[i].indexOf(&#x27;a=mid:&#x27;) === 0) {
            var mid = sdpLines[i].split(&#x27;a=mid:&#x27;)[1] || &#x27;&#x27;;
            if (mid &amp;&amp; addedMids.indexOf(mid) === -1) {
              addedMids.push(mid);
              self._addIceCandidate(targetMid, &#x27;endofcan-&#x27; + (new Date()).getTime(), new RTCIceCandidate({
                sdpMid: mid,
                sdpMLineIndex: mLineCounter,
                candidate: &#x27;candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates&#x27;
              }));
            }
          }
        }

      } else {
        self._peerConnections[targetMid].addIceCandidate(null);
      }

      if (self._gatheredCandidates[targetMid]) {
        self._trigger(&#x27;candidatesGathered&#x27;, targetMid, {
          expected: self._peerEndOfCandidatesCounter[targetMid].expectedLen || 0,
          received: self._peerEndOfCandidatesCounter[targetMid].len || 0,
          processed: self._gatheredCandidates[targetMid].receiving.srflx.length +
            self._gatheredCandidates[targetMid].receiving.relay.length +
            self._gatheredCandidates[targetMid].receiving.host.length
        });
      }

    } catch (error) {
      log.error([targetMid, &#x27;RTCPeerConnection&#x27;, null, &#x27;Failed signaling end-of-candidates -&gt;&#x27;], error);
    }
  }
};



    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>

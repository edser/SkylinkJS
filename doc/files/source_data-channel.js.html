<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/data-channel.js - skylinkjs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="skylinkjs" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.6.19</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Peer.html">Peer</a></li>
                                <li><a href="../classes/Room.html">Room</a></li>
                                <li><a href="../classes/Skylink.html">Skylink</a></li>
                                <li><a href="../classes/Socket.html">Socket</a></li>
                                <li><a href="../classes/Utils.html">Utils</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: source/data-channel.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The list of Datachannel connection states.
 * @attribute DATA_CHANNEL_STATE
 * @param {String} CONNECTING          &lt;small&gt;Value &lt;code&gt;&quot;connecting&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel is attempting to establish a connection.
 * @param {String} OPEN                &lt;small&gt;Value &lt;code&gt;&quot;open&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel has established a connection.
 * @param {String} CLOSING             &lt;small&gt;Value &lt;code&gt;&quot;closing&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel connection is closing.
 * @param {String} CLOSED              &lt;small&gt;Value &lt;code&gt;&quot;closed&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel connection has closed.
 * @param {String} ERROR               &lt;small&gt;Value &lt;code&gt;&quot;error&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel has encountered an exception during connection.
 * @param {String} CREATE_ERROR        &lt;small&gt;Value &lt;code&gt;&quot;createError&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel has failed to establish a connection.
 * @param {String} BUFFERED_AMOUNT_LOW &lt;small&gt;Value &lt;code&gt;&quot;bufferedAmountLow&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel when the amount of data buffered to be sent
 *   falls below the Datachannel threshold.
 *   &lt;small&gt;This state should occur only during after &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 *   &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; or &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; or
 *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} SEND_MESSAGE_ERROR  &lt;small&gt;Value &lt;code&gt;&quot;sendMessageError&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Datachannel when data transfer packets or P2P message fails to send.
 *   &lt;small&gt;This state should occur only during after &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 *   &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; or &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; or
 *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype.DATA_CHANNEL_STATE = {
  CONNECTING: &#x27;connecting&#x27;,
  OPEN: &#x27;open&#x27;,
  CLOSING: &#x27;closing&#x27;,
  CLOSED: &#x27;closed&#x27;,
  ERROR: &#x27;error&#x27;,
  CREATE_ERROR: &#x27;createError&#x27;,
  BUFFERED_AMOUNT_LOW: &#x27;bufferedAmountLow&#x27;,
  SEND_MESSAGE_ERROR: &#x27;sendMessageError&#x27;
};

/**
 * The list of Datachannel types.
 * @attribute DATA_CHANNEL_TYPE
 * @param {String} MESSAGING &lt;small&gt;Value &lt;code&gt;&quot;messaging&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the Datachannel type that is used only for messaging in
 *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.
 *   &lt;small&gt;However for Peers that do not support simultaneous data transfers, this Datachannel
 *   type will be used to do data transfers (1 at a time).&lt;/small&gt;
 *   &lt;small&gt;Each Peer connections will only have one of this Datachannel type and the
 *   connection will only close when the Peer connection is closed (happens when &lt;a href=&quot;#event_peerConnectionState&quot;&gt;
 *   &lt;code&gt;peerConnectionState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as
 *   &lt;code&gt;CLOSED&lt;/code&gt; for Peer).&lt;/small&gt;
 * @param {String} DATA &lt;small&gt;Value &lt;code&gt;&quot;data&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the Datachannel type that is used only for a data transfer in
 *   &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; and
 *   &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;.
 *   &lt;small&gt;The connection will close after the data transfer has been completed or terminated (happens when
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;DOWNLOAD_COMPLETED&lt;/code&gt;, &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt;,
 *   &lt;code&gt;REJECTED&lt;/code&gt;, &lt;code&gt;CANCEL&lt;/code&gt; or &lt;code&gt;ERROR&lt;/code&gt; for Peer).&lt;/small&gt;
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.DATA_CHANNEL_TYPE = {
  MESSAGING: &#x27;messaging&#x27;,
  DATA: &#x27;data&#x27;
};

/**
 * The list of Datachannel sending message error types.
 * @attribute DATA_CHANNEL_MESSAGE_ERROR
 * @param {String} MESSAGE  &lt;small&gt;Value &lt;code&gt;&quot;message&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the Datachannel sending message error type when encountered during
 *   sending P2P message from &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.
 * @param {String} TRANSFER &lt;small&gt;Value &lt;code&gt;&quot;transfer&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the Datachannel sending message error type when encountered during
 *   data transfers from &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; or
 *   &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype.DATA_CHANNEL_MESSAGE_ERROR = {
  MESSAGE: &#x27;message&#x27;,
  TRANSFER: &#x27;transfer&#x27;
};

/**
 * Function that starts a Datachannel connection with Peer.
 * @method _createDataChannel
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._createDataChannel = function(peerId, dataChannel, bufferThreshold, createAsMessagingChannel) {
  var self = this;
  var channelName = (self._user &amp;&amp; self._user.sid ? self._user.sid : &#x27;-&#x27;) + &#x27;_&#x27; + peerId;
  var channelType = createAsMessagingChannel ? self.DATA_CHANNEL_TYPE.MESSAGING : self.DATA_CHANNEL_TYPE.DATA;
  var channelProp = channelType === self.DATA_CHANNEL_TYPE.MESSAGING ? &#x27;main&#x27; : channelName;

  if (!self._user) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
      &#x27;Aborting of creating or initializing Datachannel as User does not have Room session&#x27;]);
    return;
  }

  if (!(self._peerConnections[peerId] &amp;&amp;
    self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED)) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
      &#x27;Aborting of creating or initializing Datachannel as Peer connection does not exists&#x27;]);
    return;
  }


  if (dataChannel &amp;&amp; typeof dataChannel === &#x27;object&#x27;) {
    channelName = dataChannel.label;

  } else if (typeof dataChannel === &#x27;string&#x27;) {
    channelName = dataChannel;
    dataChannel = null;
  }

  if (!dataChannel) {
    try {
      dataChannel = self._peerConnections[peerId].createDataChannel(channelName, {
        reliable: true,
        ordered: true
      });

    } catch (error) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Failed creating Datachannel -&gt;&#x27;], error);
      self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.CREATE_ERROR, peerId, error, channelName,
        channelType, null, self._getDataChannelBuffer(dataChannel));
      return;
    }
  }

  if (!self._dataChannels[peerId]) {
    channelProp = &#x27;main&#x27;;
    channelType = self.DATA_CHANNEL_TYPE.MESSAGING;
    self._dataChannels[peerId] = {};
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;initializing main DataChannel&#x27;]);
  } else if (self._dataChannels[peerId].main &amp;&amp; self._dataChannels[peerId].main.channel.label === channelName) {
    channelProp = &#x27;main&#x27;;
    channelType = self.DATA_CHANNEL_TYPE.MESSAGING;
  }

  var channel = new Datachannel(dataChannel, peerId, channelProp);

  channel.on(&#x27;state&#x27;, function (state) {
    self._trigger(&#x27;dataChannelState&#x27;, state, peerId, null, channelName, channelType, null, channel.getStats());
  });

  channel.on(&#x27;error&#x27;, function (error) {
    var bufferAmount = channel.getStats();
    self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.ERROR, peerId, error,
      channelName, channelType, null, bufferAmount);
  });

  channel.on(&#x27;bufferedamountlow&#x27;, function (error) {
    var bufferAmount = channel.getStats();
    self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.BUFFERED_AMOUNT_LOW,
      peerId, error, channelName, channelType, null, bufferAmount);
  });

  channel.on(&#x27;data&#x27;, function (data) {
    self._processDataChannelData(data, peerId, channelName, channelType);
  });

  channel.init();

  if (channelType === self.DATA_CHANNEL_TYPE.MESSAGING) {
    self._dataChannels[peerId].main = {
      channelName: channelName,
      channelType: channelType,
      transferId: null,
      streamId: null,
      channel: channel
    };
  } else {
    self._dataChannels[peerId][channelName] = {
      channelName: channelName,
      channelType: channelType,
      transferId: null,
      streamId: null,
      channel: channel
    };
  }
};

/**
 * Function that returns the Datachannel buffer threshold and amount.
 * @method _getDataChannelBuffer
 * @return {JSON} The buffered amount information.
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._getDataChannelBuffer = function (peerId, channelProp) {
  if (typeof peerId === &#x27;object&#x27;) {
    return peerId.getStats();
  } else if (!(this._dataChannels[peerId] &amp;&amp; this._dataChannels[peerId][channelProp] &amp;&amp;
    this._dataChannels[peerId][channelProp].channel)) {
    return {
      bufferedAmountLow: 0,
      bufferedAmountLowThreshold: 0
    };
  }

  return this._dataChannels[peerId][channelProp].channel.getStats();
};

/**
 * Function that sends data over the Datachannel connection.
 * @method _sendMessageToDataChannel
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._sendMessageToDataChannel = function(peerId, data, channelProp, doNotConvert, useBufferControl) {
  var self = this;

  // Set it as &quot;main&quot; (MESSAGING) Datachannel
  if (!channelProp || channelProp === peerId) {
    channelProp = &#x27;main&#x27;;
  }

  // TODO: What happens when we want to send binary data over or ArrayBuffers?
  if (!(typeof data === &#x27;object&#x27; &amp;&amp; data) &amp;&amp; !(data &amp;&amp; typeof data === &#x27;string&#x27;)) {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping invalid data -&gt;&#x27;], data);
    return;
  }

  if (!(self._peerConnections[peerId] &amp;&amp;
    self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED)) {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
      &#x27;Dropping for sending message as Peer connection does not exists or is closed -&gt;&#x27;], data);
    return;
  }

  if (!(self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId][channelProp])) {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp,
      &#x27;Dropping for sending message as Datachannel connection does not exists -&gt;&#x27;], data);
    return;
  }

  var channelName = self._dataChannels[peerId][channelProp].channelName;
  var channelType = self._dataChannels[peerId][channelProp].channelType;
  var readyState  = self._dataChannels[peerId][channelProp].channel.getStats().readyState;
  var messageType = typeof data === &#x27;object&#x27; &amp;&amp; data.type === self._DC_PROTOCOL_TYPE.MESSAGE ?
    self.DATA_CHANNEL_MESSAGE_ERROR.MESSAGE : self.DATA_CHANNEL_MESSAGE_ERROR.TRANSFER;

  if (readyState !== self.DATA_CHANNEL_STATE.OPEN) {
    var notOpenError = &#x27;Failed sending message as Datachannel connection state is not opened. Current &#x27; +
      &#x27;readyState is &quot;&#x27; + readyState + &#x27;&quot;&#x27;;

    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, notOpenError + &#x27; -&gt;&#x27;], data);

    self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.SEND_MESSAGE_ERROR, peerId, new Error(notOpenError),
      channelName, channelType, messageType, self._getDataChannelBuffer(peerId, channelProp));

    throw new Error(notOpenError);
  }

  try {
    if (!doNotConvert &amp;&amp; typeof data === &#x27;object&#x27;) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Sending &quot;&#x27; + data.type + &#x27;&quot; protocol message -&gt;&#x27;], data);

      self._dataChannels[peerId][channelProp].channel.send(JSON.stringify(data), useBufferControl);

    } else {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Sending data with size -&gt;&#x27;],
        data.size || data.length || data.byteLength);

      self._dataChannels[peerId][channelProp].channel.send(data, useBufferControl);
    }
  } catch (error) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Failed sending &#x27; + (!doNotConvert &amp;&amp; typeof data === &#x27;object&#x27; ?
      &#x27;&quot;&#x27; + data.type + &#x27;&quot; protocol message&#x27; : &#x27;data&#x27;) + &#x27; -&gt;&#x27;], error);

    self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.SEND_MESSAGE_ERROR, peerId,
      error, channelName, channelType, messageType, self._getDataChannelBuffer(peerId, channelProp));

    throw error;
  }
};

/**
 * Function that stops the Datachannel connection and removes object references.
 * @method _closeDataChannel
 * @private
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype._closeDataChannel = function(peerId, channelProp) {
  var self = this;

  if (!self._dataChannels[peerId]) {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp || null,
      &#x27;Aborting closing Datachannels as Peer connection does not have Datachannel sessions&#x27;]);
    return;
  }

  var closeFn = function (rChannelProp) {
    var channelName = self._dataChannels[peerId][rChannelProp].channelName;
    var channelType = self._dataChannels[peerId][rChannelProp].channelType;

    if (self._dataChannels[peerId][rChannelProp].channel.getStats().readyState !== self.DATA_CHANNEL_STATE.CLOSED) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Closing Datachannel&#x27;]);

      self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.CLOSING, peerId, null, channelName, channelType,
        null, self._getDataChannelBuffer(peerId, rChannelProp));

      self._dataChannels[peerId][rChannelProp].channel.close();

      delete self._dataChannels[peerId][rChannelProp];
    }
  };

  if (!channelProp) {
    for (var channelNameProp in self._dataChannels) {
      if (self._dataChannels[peerId].hasOwnProperty(channelNameProp)) {
        if (self._dataChannels[peerId][channelNameProp]) {
          closeFn(channelNameProp);
        }
      }
    }
  } else {
    if (!self._dataChannels[peerId][channelProp]) {
      log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Aborting closing Datachannel as it does not exists&#x27;]);
      return;
    }

    closeFn(channelProp);
  }
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
